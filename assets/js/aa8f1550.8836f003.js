"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2476],{64604:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var i=t(17624),s=t(4552);const r={sidebar_position:4,slug:"/lab/03"},a="03 - Exceptions & Interrupts",l={id:"lab/03/03",title:"03 - Exceptions & Interrupts",description:"The purpose of this lab is to understand how exceptions and hardware interrupts work and how they can be used, how to set a hard fault handler,",source:"@site/docs/lab/03/03.md",sourceDirName:"lab/03",slug:"/lab/03",permalink:"/docs/lab/03",draft:!1,unlisted:!1,editUrl:"https://github.com/UPB-FILS-MA/upb-fils-ma.github.io/edit/main/docs/lab/03/03.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,slug:"/lab/03"},sidebar:"tutorialSidebar",previous:{title:"02 - Memory Mapped IO & GPIO",permalink:"/docs/lab/02"},next:{title:"04 - PWM & ADC",permalink:"/docs/lab/04"}},d={},o=[{value:"Resources",id:"resources",level:2},{value:"What is an exception?",id:"what-is-an-exception",level:2},{value:"What is an interrupt?",id:"what-is-an-interrupt",level:2},{value:"Exception and Interrupt Handling",id:"exception-and-interrupt-handling",level:2},{value:"Registering handlers",id:"registering-handlers",level:3},{value:"RP2040",id:"rp2040",level:2},{value:"Boot",id:"boot",level:3},{value:"Interrupts",id:"interrupts",level:3},{value:"Available interrupt request signals (IRQ)",id:"available-interrupt-request-signals-irq",level:4},{value:"GPIO Interrupts",id:"gpio-interrupts",level:4},{value:"Inspect binaries",id:"inspect-binaries",level:2},{value:"Install cargo binutils",id:"install-cargo-binutils",level:3},{value:"Check section headers",id:"check-section-headers",level:3},{value:"Disassemble a specific section",id:"disassemble-a-specific-section",level:3},{value:"Handling a HardFault",id:"handling-a-hardfault",level:2},{value:"Register a HardFault handler",id:"register-a-hardfault-handler",level:3},{value:"Triggering a hard fault",id:"triggering-a-hard-fault",level:3},{value:"Handle Interrupts",id:"handle-interrupts",level:2},{value:"Handle Interrupts using Embedded HAL",id:"handle-interrupts-using-embedded-hal",level:2},{value:"RP2040 Embedded HAL",id:"rp2040-embedded-hal",level:3},{value:"Critical Section",id:"critical-section",level:3},{value:"Dependencies",id:"dependencies",level:3},{value:"Setting the interrupt handler",id:"setting-the-interrupt-handler",level:3},{value:"Configure the GPIO pins",id:"configure-the-gpio-pins",level:3},{value:"Enable interrupt",id:"enable-interrupt",level:3},{value:"Enable the IO_BANK0 IRQ in the NVIC",id:"enable-the-io_bank0-irq-in-the-nvic",level:3},{value:"Handling the interrupt",id:"handling-the-interrupt",level:3},{value:"Clearing the interrupt in the interrupt handler",id:"clearing-the-interrupt-in-the-interrupt-handler",level:3},{value:"Handle Interrupts using Embassy",id:"handle-interrupts-using-embassy",level:2},{value:"Define the task function",id:"define-the-task-function",level:3},{value:"Start the task",id:"start-the-task",level:3},{value:"Sharing data with tasks",id:"sharing-data-with-tasks",level:3},{value:"Exercises",id:"exercises",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"03---exceptions--interrupts",children:"03 - Exceptions & Interrupts"}),"\n",(0,i.jsxs)(n.p,{children:["The purpose of this lab is to understand how exceptions and hardware interrupts work and how they can be used, how to set a hard fault handler,\nregister interrupts and ",(0,i.jsx)(n.em,{children:"use interrupts"}),"  with embassy-rs."]}),"\n",(0,i.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Joseph Yiu"}),", ",(0,i.jsx)(n.em,{children:"The Definitive Guide to ARM\xae Cortex\xae-M0 and Cortex-M0+ Processors, 2nd Edition"})]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Chapter 4 - ",(0,i.jsx)(n.em,{children:"Architecture"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Section 4.4 - ",(0,i.jsx)(n.em,{children:"Stack Memory Operations"})]}),"\n",(0,i.jsxs)(n.li,{children:["Section 4.5 - ",(0,i.jsx)(n.em,{children:"Exceptions and Interrupts"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Chapter 8 - ",(0,i.jsx)(n.em,{children:"Exceptions and Interrupts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Section 8.1 - ",(0,i.jsx)(n.em,{children:"What are Exceptions and Interrupts"})]}),"\n",(0,i.jsxs)(n.li,{children:["Section 8.2 - ",(0,i.jsx)(n.em,{children:"Exception types on Cortex-M0 and Cortex-M0+"})]}),"\n",(0,i.jsxs)(n.li,{children:["Section 8.3 - ",(0,i.jsx)(n.em,{children:"Brief Overview of the NVIC"})]}),"\n",(0,i.jsxs)(n.li,{children:["Section 8.4 - ",(0,i.jsx)(n.em,{children:"Definition of Exception Priority Levels"})]}),"\n",(0,i.jsxs)(n.li,{children:["Section 8.5 - ",(0,i.jsx)(n.em,{children:"Vector Table"})]}),"\n",(0,i.jsxs)(n.li,{children:["Section 8.6 - ",(0,i.jsx)(n.em,{children:"Exception Sequence Overview"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Chapter 11 - ",(0,i.jsx)(n.em,{children:"Fault Handling"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Section 11.1 - ",(0,i.jsx)(n.em,{children:"Fault Exception Overview"})]}),"\n",(0,i.jsxs)(n.li,{children:["Section 11.2 - ",(0,i.jsx)(n.em,{children:"What Can Cause a Fault"})]}),"\n",(0,i.jsxs)(n.li,{children:["Section 11.7 - ",(0,i.jsx)(n.em,{children:"Lockup"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Raspberry Pi Ltd"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.a,{href:"https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf",children:"RP2040 Datasheet"})})]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Chapter 2 - ",(0,i.jsx)(n.em,{children:"System Description"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Section 2.7 - ",(0,i.jsx)(n.em,{children:"Boot sequence"})]}),"\n",(0,i.jsxs)(n.li,{children:["Section 2.8 - ",(0,i.jsx)(n.em,{children:"Bootrom"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Subsection 2.8.1 - ",(0,i.jsx)(n.em,{children:"Processor Controlled Boot Sequence"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://developer.arm.com/documentation/dui0662/latest/",children:"Cortex-M0+ Devices Generic User Guide"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.rs/rp2040-hal/0.10.0/rp2040_hal/index.html",children:"rp2040-hal documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://embassy.dev/book/dev/runtime.html",children:"Embassy documentation"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"what-is-an-exception",children:"What is an exception?"}),"\n",(0,i.jsxs)(n.p,{children:["Exceptions describe any condition that requires the processor to stop what it is doing\nand do something else. Section 2.3.2 of ",(0,i.jsx)(n.a,{href:"https://documentation-service.arm.com/static/5f04abc8dbdee951c1cdc9f7?token=",children:"Cortex-M0+ Devices generic User Guide"})," lists 7 types of exceptions:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Exception"}),(0,i.jsx)(n.th,{children:"Priority"}),(0,i.jsx)(n.th,{children:"Descriptions"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Reset"}),(0,i.jsx)(n.td,{children:"-15"}),(0,i.jsx)(n.td,{children:"Triggered by the system at startup to start the software"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"NMI"}),(0,i.jsx)(n.td,{children:"-14"}),(0,i.jsx)(n.td,{children:"Non Maskable Interrupts, an external interrupt that cannot be ignored, usually used for low latency peripheral needs the attention of the MCU"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"HardFault"}),(0,i.jsx)(n.td,{children:"-13"}),(0,i.jsx)(n.td,{children:"Triggered by the MCU in case of a fault (div by 0, memory fault, ...)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"SVC"}),(0,i.jsx)(n.td,{children:"-5"}),(0,i.jsx)(n.td,{children:"Supervisor call, triggered usually by a process running on top of the embedded operating system when it wants to make a system call"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"PendSV"}),(0,i.jsx)(n.td,{children:"-2"}),(0,i.jsx)(n.td,{children:"Used for pending system calls"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"SysTick"}),(0,i.jsx)(n.td,{children:"-1"}),(0,i.jsx)(n.td,{children:"Triggered by a periodic timer, usually used by an embedded operating system for context switch"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Interrupt (IRQ)"}),(0,i.jsx)(n.td,{children:"0 and above"}),(0,i.jsx)(n.td,{children:"Triggered by a peripheral, or generated by a software request"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"what-is-an-interrupt",children:"What is an interrupt?"}),"\n",(0,i.jsx)(n.p,{children:"A hardware interrupt is a type of exception which is a synchronous or asynchronous signal from a peripheral that signals the occurrence of an event that must be handled by the processor. Interrupt handling has the effect of suspending a program's normal thread of execution and launching an interrupt service routine (ISR)."}),"\n",(0,i.jsx)(n.p,{children:"Generally, to associate an interrupt with a specific routine in the program, the processor uses the interrupt vector table (IVT). In this table, each interrupt is associated with the address to which the program will jump when the interrupt is triggered. These addresses are predefined and are mapped in program memory."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"InterruptVector",src:t(11924).c+"",width:"564",height:"670"})}),"\n",(0,i.jsx)(n.p,{children:"The image above illustrates the whole  vector table of ARM Cortex-M0.\nIt includes exceptions mapped from address 0x04 to 0x40+4n (n depends on the processor type). Lower address means higher priority.\nHigher priority exceptions can interrupt lower priority exceptions."}),"\n",(0,i.jsx)(n.h2,{id:"exception-and-interrupt-handling",children:"Exception and Interrupt Handling"}),"\n",(0,i.jsx)(n.p,{children:"When an interrupt request happens the first thing that the processor does is to memorize its current state. For ARM Cortex-M0 this happens by pushing 8 words or registered data into the main stack to provide the information\nneed to return the processor to what it was doing before before the interrupt request was called. This part is called the stack frame and it includes registers 0 through 3, register 12, the link register, the program counter and the program status register."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"StackFrame",src:t(74748).c+"",width:"1054",height:"602"})}),"\n",(0,i.jsx)(n.p,{children:'ARM Cortex-M microcontrollers also use a Nested Vectored Interrupt Controller (NVIC).The NVIC is specifically designed to handle these interrupts more efficiently. Interrupt addresses in the NVIC memory region are set according to their priority: the lower the address, the higher the priority. As suggested by the "Nested" in its name, the NVIC supports nested interrupts. This means that if a higher priority interrupt occurs while another interrupt is being processed, the controller can pause the current interrupt service routine (ISR), handle the higher priority interrupt, and then resume the interrupted ISR. This feature is crucial for responsive and real-time processing.'}),"\n",(0,i.jsx)(n.h3,{id:"registering-handlers",children:"Registering handlers"}),"\n",(0,i.jsxs)(n.p,{children:["Exception handlers are registered using the ",(0,i.jsx)(n.code,{children:"exception"})," macro provided by the ",(0,i.jsx)(n.code,{children:"cortex-m-rt"})," crate."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[exception]\nunsafe fn ExceptionName() {\n\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["The name of the exception handler function matters, as this is the way the ",(0,i.jsx)(n.code,{children:"exception"})," macro knows for which exception to\nregister the handler. Valid exception names are ",(0,i.jsx)(n.code,{children:"HardFault"}),", ",(0,i.jsx)(n.code,{children:"SysTick"}),", or any other exception name of the MCU."]})}),"\n",(0,i.jsxs)(n.p,{children:["Interrupt handlers are registered using the ",(0,i.jsx)(n.code,{children:"interrupt"})," macro provided by the ",(0,i.jsx)(n.code,{children:"cortex-m-rt"})," crate."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[interrupt]\nunsafe fn IRQ_NAME() {\n\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["The name of the interrupt handler function matters, as this is the way the ",(0,i.jsx)(n.code,{children:"interrupt"})," macro knows for which interrupt to\nregister the handler. Valid exception names are any of the ",(0,i.jsx)(n.a,{href:"#available-interrupt-request-signals-irq",children:"provided interrupts"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"rp2040",children:"RP2040"}),"\n",(0,i.jsx)(n.p,{children:"The RP2040 is an ARM Cortex-M0+ dual core processor. It does have some particularities."}),"\n",(0,i.jsx)(n.h3,{id:"boot",children:"Boot"}),"\n",(0,i.jsx)(n.p,{children:"The RP2040 boots from an internal bootloader that sets the initial interrupt IVT."}),"\n",(0,i.jsx)(n.mermaid,{value:"flowchart LR\n    S(PowerUp) --\x3e I\n    subgraph I0[Internal Boot Loader]\n        I{BOOTSEL\n        Pressed} -- Yes --\x3e U\n        I -- NO --\x3e R(Read \n        Boot Loader \n        @x1000_0000)\n        R -- Error --\x3e U(Show USB \n        Drive)\n    end\n    R -- Success --\x3e E2(Load\n    Interrupt\n    Vector)\n    E2 -- Fault --\x3e E3(Jump to \n    HardFault \n    Handler)\n    E3 -- Fault --\x3e L(Lockup\n    or\n    Reset)\n    E2 --\x3e S2(Set Stack \n    Pointer)\n    S2 --\x3e E(Jump to \n    Reset \n    Exception \n    Handler)\n    E -- Invalid --\x3e E3\n    E --\x3e F(Fetch \n    Instruction)\n\n    classDef memory fill:#B0E3E6,stroke:#0E8088\n    classDef instruction fill:#B1DDF0,stroke:#10739E\n    classDef processor fill:#FFE6CC,stroke:#D79B00\n    classDef exception fill:#F8CECC,stroke:#B85450\n    classDef error fill:#ff0000,stroke:#ae0000,color:#ffffff\n    classDef start fill:#00ef00\n    classDef rom fill:#f7ffe7\n\n    class A,E,E2,S2 instruction\n    class R,F memory\n    class B,V,R2,I,I2,I3,H,U processor\n    class L error\n    class E3 exception\n    class S start\n    class I0 rom"}),"\n",(0,i.jsxs)(n.p,{children:["The before starting the actual code written into Flash, the internal bootloader loads a secondary bootloader that\nis written in Flash (the first 256 bytes) together with the developer's app.\nThis is the bootloader section that was described in ",(0,i.jsx)(n.a,{href:"/docs/lab/02#bootloader",children:"lab 02"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The IVT that the Flash application provides start after the secondary bootloader, at address 0x100."}),"\n",(0,i.jsx)("div",{align:"center",children:(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"FlashAddress",src:t(23668).c+"",width:"405",height:"695"})})}),"\n",(0,i.jsx)(n.h3,{id:"interrupts",children:"Interrupts"}),"\n",(0,i.jsx)(n.p,{children:"The RP2040 chip has two cores (processors), and each core has its own NVIC. Each core's NVIC is connected to the same set of hardware interrupt lines with one exception: IO Interrupts. In the RP2040, IO interrupts are organized by banks, and each core has its own set of IO interrupts for each bank. The IO interrupts for each core are completely independent. For instance, Processor 0 (Core 0) can be interrupted by an event on GPIO pin 0 in bank 0, while Processor 1 (Core 1) can be interrupted by a separate event on GPIO pin 1 in the same bank. Each processor responds only to its own interrupts, allowing them to operate independently or to handle different tasks simultaneously without interfering with each other."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"rp2040 subsystem",src:t(72660).c+"",width:"845",height:"369"})}),"\n",(0,i.jsx)(n.h4,{id:"available-interrupt-request-signals-irq",children:"Available interrupt request signals (IRQ)"}),"\n",(0,i.jsx)(n.p,{children:"On RP2040, only the lower 26 IRQ signals are connected on the NVIC, as seen in the table below, and IRQs 26 to 31 are tied to zero (never firing).\nThe core can still be forced to enter the relevant interrupt handler by writing bits 26 to 31 in the NVIC ISPR register."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Supported IRQ",src:t(37180).c+"",width:"701",height:"228"})}),"\n",(0,i.jsx)(n.p,{children:"The priority order is determined for these signals is determined by :"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["First, the dynamic priority level configured per interrupt by the ",(0,i.jsx)(n.code,{children:"NVIC_IPR0-7"})," registers. The Cortex-M0+ implements\nthe two most significant bits of an 8-bit priority field, so four priority levels are available, and the numerically-lowest\nlevel (level 0) is the highest priority."]}),"\n",(0,i.jsx)(n.li,{children:"Second, for interrupts with the same dynamic priority level, the lower-numbered IRQ has higher priority (using the\nIRQ numbers given in the table above)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"NVIC by prio",src:t(91344).c+"",width:"906",height:"635"})}),"\n",(0,i.jsx)(n.h4,{id:"gpio-interrupts",children:"GPIO Interrupts"}),"\n",(0,i.jsx)(n.p,{children:"All GPIO pins in Raspberry Pi Pico support interrupts. The interrupts can be classified into three types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Level High"}),": An interrupt occurs while a pin is HIGH or at logic 1."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Level Low"}),": An interrupt occurs while a pin is LOW or at logic 0."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Rising Edge"}),": Interrupt occurs when a pin transitions from a LOW to HIGH."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Falling Edge"}),": Interrupt occurs when a pin transitions from HIGH to LOW."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"alt text",src:t(98932).c+"",width:"448",height:"164"})}),"\n",(0,i.jsx)(n.h2,{id:"inspect-binaries",children:"Inspect binaries"}),"\n",(0,i.jsxs)(n.p,{children:["When working in Rust, ",(0,i.jsx)(n.code,{children:"rust-objdump"})," can be used to inspect the compiled output to see sections and interleaved code. This is particularly useful to inspect code and debug."]}),"\n",(0,i.jsx)(n.h3,{id:"install-cargo-binutils",children:"Install cargo binutils"}),"\n",(0,i.jsxs)(n.p,{children:["Before you can use ",(0,i.jsx)(n.code,{children:"rust-objdump"})," with Rust projects, you'll need to install ",(0,i.jsx)(n.code,{children:"cargo-binutils"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cargo install cargo-binutils\nrustup component add llvm-tools-preview\n"})}),"\n",(0,i.jsx)(n.h3,{id:"check-section-headers",children:"Check section headers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"rust-objdump --section-headers target/thumbv6m-none-eabi/debug/<executable_name>\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"\nSections:\nIdx Name            Size     VMA      Type\n  0                 00000000 00000000 \n  1 .vector_table   000000c0 10000100 DATA\n  2 .boot_loader    00000100 10000000 DATA\n  3 .text           00000b10 100001c0 TEXT\n  4 .rodata         000001a4 10000cd0 DATA\n  5 .data           00000000 20000000 DATA\n  6 .gnu.sgstubs    00000000 10000e80 TEXT\n  7 .bss            00000000 20000000 BSS\n  8 .uninit         00000000 20000000 BSS\n  9 .debug_abbrev   00001bce 00000000 DEBUG\n 10 .debug_info     00025316 00000000 DEBUG\n 11 .debug_aranges  000014b8 00000000 DEBUG\n 12 .debug_str      0003c860 00000000 DEBUG\n 13 .debug_pubnames 000175c6 00000000 DEBUG\n 14 .debug_pubtypes 00000ee6 00000000 DEBUG\n 15 .comment        00000073 00000000 \n 16 .ARM.attributes 00000032 00000000 \n 17 .debug_frame    00004444 00000000 DEBUG\n 18 .debug_line     00023790 00000000 DEBUG\n 19 .debug_ranges   00016df8 00000000 DEBUG\n 20 .debug_loc      00000074 00000000 DEBUG\n 21 .symtab         00000970 00000000 \n 22 .shstrtab       00000103 00000000 \n 23 .strtab         00000fe4 00000000 \n"})}),"\n",(0,i.jsx)(n.h3,{id:"disassemble-a-specific-section",children:"Disassemble a specific section"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"rust-objdump --disassemble -j .section_name target/thumbv6m-none-eabi/debug/<executable_name>\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"cargo objdumb"})," and ",(0,i.jsx)(n.code,{children:"rust-objdump"})," tools use llvm's ",(0,i.jsx)(n.code,{children:"objdump"})," tool.\nSome terminals do not parse parameters proxied to ",(0,i.jsx)(n.code,{children:"llvm-objdump"})," command.\nIf this happens please use ",(0,i.jsx)(n.code,{children:"llvm-objdump"})," script directly like so"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"llvm-objdump <path_to_binary> --section.headers\n"})})]}),"\n",(0,i.jsx)(n.h2,{id:"handling-a-hardfault",children:"Handling a HardFault"}),"\n",(0,i.jsx)(n.p,{children:"There are several reasons why a hard fault is triggered:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"invalid memory"})," reads and writes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"invalid"})," address of the ",(0,i.jsx)(n.em,{children:"reset handler"})," (not the case for RP2040, as the real reset handler is in the Bootrom)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"invalid"})," address of the ",(0,i.jsx)(n.em,{children:"initial stack pointer"})," (not the case for RP2040, as the real reset handler is in the Bootrom)"]}),"\n",(0,i.jsxs)(n.li,{children:["using the ",(0,i.jsx)(n.em,{children:"svc"})," instruction ",(0,i.jsx)(n.em,{children:"in the HardFault handler"})]}),"\n",(0,i.jsxs)(n.li,{children:["using the ",(0,i.jsx)(n.em,{children:"svc"})," instruction ",(0,i.jsx)(n.em,{children:"NMI handler"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"register-a-hardfault-handler",children:"Register a HardFault handler"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"cortex-m-rt"})," crate allows an easy way of registering a hard fault handler by using\nthe ",(0,i.jsx)(n.code,{children:"exception"})," macro."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[exception]\nunsafe fn HardFault(_frame: &ExceptionFrame) -> ! {\n    loop{}\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ExceptionFrame"})," parameter contains the state of the processor at the moment of the hard fault occurred.\nIt contains the stack frame (registers) that the processor pushed on the stack."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"The hard fault handler is not allowed to return, as usual. Unless an embedded operating system is used, this error is not recoverable."})}),"\n",(0,i.jsx)(n.h3,{id:"triggering-a-hard-fault",children:"Triggering a hard fault"}),"\n",(0,i.jsxs)(n.p,{children:["The easiest way of forcing a hard fault is to try to read or write to or from a memory location that is not valid.\nFor the RP2040, an invalid memory address is ",(0,i.jsx)(n.code,{children:"0xf000_0000"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// define an invalid memory address\nconst INVALID_ADDRESS: *mut u32 = 0xf000_0000 as *mut u32;\n\n// write to it\nunsafe {\n    // this triggers a hard fault\n    write_volatile(INVALID_ADDRESS, 0);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"handle-interrupts",children:"Handle Interrupts"}),"\n",(0,i.jsx)(n.p,{children:"This labs presents two ways of handling interrupts:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"using the embedded-hal"})," standard which implies actually registering interrupt handlers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"using embassy"})," which is a framework that provides an API that uses interrupts"]}),"\n"]}),"\n",(0,i.jsx)("div",{align:"center",children:(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"EmbeddedStack",src:t(69408).c+"",width:"451",height:"291"})})}),"\n",(0,i.jsx)(n.h2,{id:"handle-interrupts-using-embedded-hal",children:"Handle Interrupts using Embedded HAL"}),"\n",(0,i.jsx)(n.p,{children:"Setting up an interrupt is a bit more complicated than handling\na simple exception because we also need to enable that interrupt and bind it to the signal coming from a peripheral.\nAdditionally, we need to manually clear the interrupt (signal that we handled the interrupt) in the\ninterrupt handler, otherwise as soon as the interrupt handler finishes, it gets called again."}),"\n",(0,i.jsx)(n.h3,{id:"rp2040-embedded-hal",children:"RP2040 Embedded HAL"}),"\n",(0,i.jsxs)(n.p,{children:["Setting up interrupts requires a lot of register logic. To make this task easier, instead of using directly\nthe PAC, we can use a crate that implements the ",(0,i.jsx)(n.code,{children:"embedded-hal"})," traits and which exports easier functions."]}),"\n",(0,i.jsx)(n.p,{children:"We need a way to make sure that the data we access and modify stays consistent, regardless of when ISR are called\nand executed."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://docs.rs/rp2040-hal/0.10.0/rp2040_hal/index.html",children:(0,i.jsx)(n.code,{children:"rp2040-hal"})})," crate provides such functionality."]}),"\n",(0,i.jsx)(n.h3,{id:"critical-section",children:"Critical Section"}),"\n",(0,i.jsx)(n.p,{children:"As interrupts can fire at any time, there is no way to know when the normal application flow will be\ninterrupted. This can happen while writing data to registers or while reconfiguring the interrupts."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://docs.rs/critical-section/latest/critical_section/",children:(0,i.jsx)(n.code,{children:"critical-section"})})," crate does just that.\nFor single core MCUs (the way in which we use in this lab the RP2040) ",(0,i.jsx)(n.code,{children:"critical_section::with"})," function simply\ndisable any interrupts while in the critical section."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"critical_section::with(|cs| {\n    // on cortex-m single core MCUs\n    // run code that should not be interrupted\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,i.jsxs)(n.p,{children:["To make sure we can use ",(0,i.jsx)(n.a,{href:"https://docs.rs/rp2040-hal/0.10.0/rp2040_hal/index.html",children:(0,i.jsx)(n.code,{children:"rp2040-hal"})})," and ",(0,i.jsx)(n.a,{href:"https://docs.rs/critical-section/latest/critical_section/",children:(0,i.jsx)(n.code,{children:"critical-section"})}),", we have to add the following dependencies to\nthe ",(0,i.jsx)(n.code,{children:"Cargo.toml"})," file."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'# offers the critical section API\ncritical-section = "1.1.2"\n\n# the "critical-section-impl" features provides the implementation of \n# the critical-section API for rp2040\nrp2040-hal = { version = "0.10.0", features = ["rt", "critical-section-impl"] }\n'})}),"\n",(0,i.jsx)(n.h3,{id:"setting-the-interrupt-handler",children:"Setting the interrupt handler"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"#[interrupt]"})," macro allows us to register a function as interrupt handler."]}),"\n",(0,i.jsxs)(n.p,{children:["Usually interrupt handlers have to access global data. Due to Rust's safety rules, this is not\ndirectly allowed. The Rust compiler needs to ",(0,i.jsx)(n.em,{children:"make sure at compile time"})," that there is no way\nthe code could corrupt the data that it reads or writes.\nThis is why interrupts handler\nhave to use ",(0,i.jsx)(n.code,{children:"critical_section"})," to access data."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use rp2040_pac::interrupt;\n\n#[interrupt]\nunsafe fn IO_IRQ_BANK0() {\n    critical_section::with(|cs| {\n        // access global data\n    });\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"configure-the-gpio-pins",children:"Configure the GPIO pins"}),"\n",(0,i.jsxs)(n.p,{children:["In this example we want to trigger the ",(0,i.jsx)(n.code,{children:"IO_IRQ_BANK0"})," interrupt when a pin is pressed. We have\nto use the ",(0,i.jsx)(n.a,{href:"https://docs.rs/rp2040-hal/0.10.0/rp2040_hal/index.html",children:(0,i.jsx)(n.code,{children:"rp2040-hal"})})," API to configure\nthe GPIO pins."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use rp2040_hal::gpio::{\n    FunctionSioInput, Pin, Pins, PullUp,\n};\n\n// get the peripherals\nlet mut peripherals = Peripherals::take().unwrap();\n\n// initialize the SIO (this is different from PAC, as we use the rp2040-hal)\nlet sio = Sio::new(peripherals.SIO);\n\n// initialize the pins part of SIO\nlet pins = Pins::new(\n    peripherals.IO_BANK0,\n    peripherals.PADS_BANK0,\n    sio.gpio_bank0,\n    &mut peripherals.RESETS,\n);\n\n// configure the input pin\n// replace X with a pin number\nlet pin: Pin<GpioX, FunctionSioInput, PullUp> = pins.gpioX.reconfigure();\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Do not forget to replace the ",(0,i.jsx)(n.code,{children:"X"})," in ",(0,i.jsx)(n.code,{children:"GpioX"})," and ",(0,i.jsx)(n.code,{children:"gpioX"})," with an actual pin number."]})}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["Please note the way the pin was configured. The configuration is written into the ",(0,i.jsx)(n.strong,{children:"data type"}),",\nthat is ",(0,i.jsx)(n.code,{children:"Pin<GpioX, FunctionSioInput, PullUp>"}),") instead of the ",(0,i.jsx)(n.code,{children:"reconfigure"})," function's parameters. This is one of Rust's\nimportant features, as it prevents using invalid functions on pin that was configured in a certain way."]}),(0,i.jsxs)(n.p,{children:["The data type returned by the ",(0,i.jsx)(n.code,{children:"reconfigure"})," function simply does not have functions that do not work\nfor the configuration."]})]}),"\n",(0,i.jsx)(n.h3,{id:"enable-interrupt",children:"Enable interrupt"}),"\n",(0,i.jsx)(n.p,{children:"Now that the interrupt handler is registered and the pin is configured, we can enable the interrupt."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use rp2040_hal::Interrupt;\n\n// Trigger on the 'falling edge' of the input pin.\n// This will happen as the button is being pressed\npin.set_interrupt_enabled(Interrupt::EdgeLow, true);\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"enable-the-io_bank0-irq-in-the-nvic",children:"Enable the IO_BANK0 IRQ in the NVIC"}),"\n",(0,i.jsxs)(n.p,{children:["While the interrupt has been enabled inside the ",(0,i.jsx)(n.em,{children:"IO_Bank0"})," peripheral, we still\nneed to ask the ",(0,i.jsx)(n.em,{children:"NVIC"})," peripheral to signal the processor then ",(0,i.jsx)(n.em,{children:"IO_Bank0"})," triggers\nthe interrupt. This is done using the API of the PAC crate."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"unsafe {\n    rp2040_pac::NVIC::unmask(rp2040_pac::Interrupt::IO_IRQ_BANK0);\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Without enabling the interrupt in ",(0,i.jsx)(n.em,{children:"NVIC"}),", the MCU will never be interrupted by the ",(0,i.jsx)(n.code,{children:"IO_IRQ_BANK0"}),"\ninterrupt, as NVIC will never signal the MCU. In this situation, we say that the NVIC ",(0,i.jsx)(n.em,{children:"masks"})," the interrupt."]})}),"\n",(0,i.jsx)(n.h3,{id:"handling-the-interrupt",children:"Handling the interrupt"}),"\n",(0,i.jsxs)(n.p,{children:["Several pins can be configured to trigger the ",(0,i.jsx)(n.code,{children:"IO_IRQ_BANK0"})," interrupt. It is the ISR's (handler's) job\nto talk to ",(0,i.jsx)(n.em,{children:"IO_BANK0"})," and ask which pin triggered the interrupt. Moreover, the interrupt will stay active until\nthe ISR asks the ",(0,i.jsx)(n.em,{children:"IO_BANK0"})," to clear it."]}),"\n",(0,i.jsxs)(n.p,{children:["To perform this task, the ISR needs access to the ",(0,i.jsx)(n.code,{children:"pin"})," variable that we configured before. The problem is\nthat this ",(0,i.jsx)(n.code,{children:"pin"})," variable is a local variable, probably defined in the ",(0,i.jsx)(n.code,{children:"main"})," function. As Rust does not\nallow global variables, we have to use a combination of the ",(0,i.jsx)(n.code,{children:"critical-section"})," API and a ",(0,i.jsx)(n.code,{children:"Mutex"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"First, we define a data type structure that will hold the global variables that we need.\nFor this example it holds the pin."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct GlobalData {\n    pin: Pin<GpioX, FunctionSioInput, PullUp>\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Next we have to define a ",(0,i.jsx)(n.code,{children:"static"})," variable of type ",(0,i.jsx)(n.code,{children:"GlobalPin"}),". Just defining the static variable is not enough,\nas Rust will never allow us to modify it. Rust does not allow global mutable static variables due to safety reasons."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"static GLOBAL_DATA: Mutex<Cell<Option<GlobalData>>> = Mutex::new(Cell::new(None));\n"})}),"\n",(0,i.jsx)(n.p,{children:"The type definition is a little long, let's take a close look at it:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["to be able to ",(0,i.jsx)(n.strong,{children:"share"})," ",(0,i.jsx)(n.code,{children:"global_data"})," between the ",(0,i.jsx)(n.code,{children:"main"})," function and the ISR, we have to use a ",(0,i.jsx)(n.code,{children:"Mutex"}),", as the ISR can execute anytime. The ",(0,i.jsx)(n.code,{children:"Mutex"})," assures that only one execution flow at a time can access the value sitting inside, in this example either ",(0,i.jsx)(n.code,{children:"main"})," either the ISR"]}),"\n",(0,i.jsxs)(n.li,{children:["to be able to ",(0,i.jsx)(n.strong,{children:"modify"})," the value inside the ",(0,i.jsx)(n.code,{children:"Mutex"})," we have to wrap the value in a ",(0,i.jsx)(n.code,{children:"Cell"})]}),"\n",(0,i.jsxs)(n.li,{children:["to be able to have an ",(0,i.jsx)(n.strong,{children:"initial unconfigured"})," value, as the ",(0,i.jsx)(n.code,{children:"GLOBAL_DATA"}),"'s value is only configured within ",(0,i.jsx)(n.code,{children:"main"})," with actual data, we have tu use Rust's principle of NULL, ",(0,i.jsx)(n.code,{children:"Option"}),", the ",(0,i.jsx)(n.code,{children:"GLOBAL_DATA"})," will be initially set to ",(0,i.jsx)(n.code,{children:"None"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["We have to change the pin initialization and store the ",(0,i.jsx)(n.code,{children:"pin"})," into the ",(0,i.jsx)(n.code,{children:"GLOBAL_DATA"})," variable."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let local_data = GlobalData {\n    pin: pins.gpio25.reconfigure(),\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As soon as we have the ",(0,i.jsx)(n.code,{children:"local_data"})," variable initialized (using a local variable), we have to store it in to a global variable."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:" critical_section::with(|cs| {\n    GLOBAL_DATA.borrow(cs).replace(Some(local_data));\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"clearing-the-interrupt-in-the-interrupt-handler",children:"Clearing the interrupt in the interrupt handler"}),"\n",(0,i.jsxs)(n.p,{children:["When the ",(0,i.jsx)(n.code,{children:"IO_IRQ_BANK0"})," interrupt triggers, we use the ",(0,i.jsx)(n.code,{children:"critical-section"})," to retrieve the value of the\n",(0,i.jsx)(n.code,{children:"GLOBAL_DATA"})," variable and use the ",(0,i.jsx)(n.code,{children:"pin"})," field to ask ",(0,i.jsx)(n.em,{children:"IO_Bank0"})," to clear the interrupt that just triggered."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Failing to ask ",(0,i.jsx)(n.em,{children:"IO_Bank0"})," to clear the interrupt within the ISR will lead to the ISR being called again."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[interrupt]\nunsafe fn IO_IRQ_BANK0() {\n    critical_section::with(|cs| {\n        let mut global_data = GLOBAL_DATA.borrow(cs).take();\n\n        if let Some(ref mut data) = global_data {\n            // execute some actions\n            data.switch_a.clear_interrupt(Interrupt::EdgeLow);\n        }\n\n        GLOBAL_DATA.borrow(cs).replace(global_data);\n    });\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["The way this interrupt handler uses ",(0,i.jsx)(n.code,{children:"critical-section"})," is not the most optimal, but it is the easiest to understand.\nInterrupt handlers should execute as less code as possible inside the ",(0,i.jsx)(n.code,{children:"critical-section"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"handle-interrupts-using-embassy",children:"Handle Interrupts using Embassy"}),"\n",(0,i.jsx)(n.p,{children:"In Embassy, handling interrupts does not involve manually setting up interrupt service routines (ISRs) in the traditional sense that you might be used to with bare-metal or lower-level embedded programming. Instead, Embassy abstracts away the hardware-specific details and provides a higher-level async API for working with hardware events, including interrupts."}),"\n",(0,i.jsxs)(n.p,{children:["Embassy uses Rust's ",(0,i.jsx)(n.code,{children:"async"}),"/",(0,i.jsx)(n.code,{children:"await"})," syntax to provide an easier way to write non-blocking embedded applications. This approach allows you to wait for events (like GPIO pin changes, which could be triggered by hardware interrupts underneath), in a way that looks synchronous but is actually non-blocking and handled asynchronously by the Embassy executor."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"The async and await mechanisms will be discussed in more detail in course_04 and lab_05."})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"alt text",src:t(26780).c+"",width:"827",height:"709"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Unlike the usb drive, GPIO pins don't need explicit interrupt binding.\nAll interrupts handlers are already associated to the type of the input signal (rising edge, level low etc.)"})}),"\n",(0,i.jsx)(n.p,{children:"For example, if you're waiting for a button press, you don't need to set up the interrupt yourself; you simply use Embassy's GPIO API to wait for the pin change event."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"button.wait_for_rising_edge().await\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If we want the main loop to keep running regardless of the button state, we need to define a new task. A task in Embassy is an ",(0,i.jsx)(n.code,{children:"async"})," function that will run in parallel with other tasks. It can pause its execution at certain points, waiting for some conditions to be met (like waiting for an I/O operation to complete, a timer to elapse, or an external event to occur), and then resume where it left off."]}),"\n",(0,i.jsx)(n.h3,{id:"define-the-task-function",children:"Define the task function"}),"\n",(0,i.jsx)(n.p,{children:"The task function receives the button as an parameter."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// replace X with the button's pin number\n#[embassy_executor::task]\nasync fn button_pressed(mut button: Input<'static, PIN_X>) {\n    // initialize gpio\n    loop {\n        \n        // Wait for the button button to be pressed\n        button.wait_for_rising_edge().await;\n        // Do something only if button was pressed\n        // (Here should be the logic for your interrupt request handler)\n        // Example: turn on the LED\n        \n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"start-the-task",children:"Start the task"}),"\n",(0,i.jsxs)(n.p,{children:["The main embassy task initializes the device and the button, starts the ",(0,i.jsx)(n.code,{children:"button_pressed"})," task and does its work."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use embassy_executor::Spawner;\n\n#[embassy_executor::main]\nasync fn main(spawner: Spawner) {\n    \n    // let button = ...\n\n    //  Spawn button_pressed and send the button an argument\n    spawner.spawn(button_pressed(button)).unwrap();\n\n    loop {\n        // Do something\n        // ...\n    }\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Tasks are scheduled in a cooperative way. This means that the current task has to stop by using the ",(0,i.jsx)(n.code,{children:"await"})," keyword and ask\nthe scheduler to schedule another task.\nThe ",(0,i.jsx)(n.code,{children:"main"})," task has to use ",(0,i.jsx)(n.code,{children:"await"})," at some point. Failure to do that will prevent the ",(0,i.jsx)(n.code,{children:"button_pressed"})," task from running."]})}),"\n",(0,i.jsx)(n.h3,{id:"sharing-data-with-tasks",children:"Sharing data with tasks"}),"\n",(0,i.jsxs)(n.p,{children:["If several tasks need to share the same data, a ",(0,i.jsx)(n.code,{children:"Mutex"})," similar to the one from Embedded HAL is needed."]}),"\n",(0,i.jsx)(n.p,{children:"If tasks just need to send values to each other, sending them as arguments should work."}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Pico Explorer Pinout",src:t(42220).c+"",width:"800",height:"600"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Connect an LED1 to pin 0 and an LED2 to pin 1. Use ",(0,i.jsx)(n.a,{href:"https://www.kicad.org/",children:"KiCad"})," to draw the schematics. (",(0,i.jsx)(n.strong,{children:"1p"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Write a program using ",(0,i.jsx)(n.code,{children:"embedded-hal"})," that blinks the LED1. Use ",(0,i.jsx)(n.code,{children:"rust-objdump"})," to display the sections. (",(0,i.jsx)(n.strong,{children:"2p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"You should be able to see the:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"bootloader section"}),"\n",(0,i.jsx)(n.li,{children:"interrupt vector"}),"\n",(0,i.jsx)(n.li,{children:"the code part (.text segment)"}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["To blink a led using ",(0,i.jsx)(n.code,{children:"embedded-hal"}),", take a look at ",(0,i.jsx)(n.a,{href:"../lab/02#configure-gpio-output",children:"Configuring GPIO Output in Embassy"}),", from Lab 2. Embassy uses ",(0,i.jsx)(n.code,{children:"embedded-hal"}),", so the functions for setting pin values to HIGH or LOW would be the same."]})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:["Register a hard fault handler that blinks LED2. (",(0,i.jsx)(n.strong,{children:"3p"}),")","\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Generate a hard fault, you should see LED1 stop blinking (either on or off) and the LED2 blink"}),"\n",(0,i.jsxs)(n.li,{children:["Move the blinking LED2 code to the panic handler and call panic!() in ",(0,i.jsx)(n.code,{children:"main"})," after a few LED1 blink loops"]}),"\n",(0,i.jsx)(n.li,{children:"Make sure panic is called when a hard fault is generated and generate a hard fault after a few LED1 blink loops"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["All crates used in this lab have a github repo, please check ",(0,i.jsxs)(n.a,{href:"https://github.com/rp-rs/rp-hal/tree/main/rp2040-hal",children:[(0,i.jsx)(n.code,{children:"rp2040-hal"}),"'s repository"]}),". You have there multiple examples of how to set up the gpio pins."]}),(0,i.jsxs)(n.p,{children:["A very usefull example of how to setup multiple input and output pins and how to access them safely is: ",(0,i.jsx)(n.a,{href:"https://github.com/rp-rs/rp-hal/blob/main/rp2040-hal/examples/gpio_irq_example.rs",children:"gpio_irq_example.rs"}),"."]})]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:"The code written in hard fault handlers has to be very basic, as it is not very clear what triggered it.\nWe suggest using bare metal to blink the LED. The code cannot assume that any peripheral is already\ninitialized, as the fault might have occurred while initializing the board."}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// reset IO Bank0\nconst RESET: u32 = 0x4000_c000;\nconst CLR: u32 = 0x3000;\n\nconst RESET_DONE: u32 = 0x4000_c008;\n\nconst GPIOX_CTRL: u32 = 0x4001_4004;\nconst GPIO_OE_SET: *mut u32 = 0xd000_0024 as *mut u32;\nconst GPIO_OUT_SET: *mut u32 = 0xd000_0014 as *mut u32;\nconst GPIO_OUT_CLR: *mut u32 = 0xd000_0018 as *mut u32;\n\n// TODO - use fill in the GPIO number for LED2\nconst LED: u32 = ;\n\nunsafe {\n    write_volatile((RESET + CLR) as *mut u32, 1 << 5);\n    while read_volatile(RESET_DONE as *const u32) & (1 << 5) == 0 {}\n}\n\n// set the LED pin the SIO function in IO_BANK0\nlet gpio_ctrl = (GPIOX_CTRL + 8 * LED) as *mut u32;\nunsafe {\n    write_volatile(gpio_ctrl, 5);\n};\n\n// set the LED pin as output in SIO\nunsafe {\n    write_volatile(GPIO_OE_SET, 1 << LED);\n};\n\nlet mut value = 0;\n\nloop {\n    value = 1 - value;\n    // write the value to the LED\n    let reg = match value {\n        0 => GPIO_OUT_CLR,\n        _ => GPIO_OUT_SET,\n    };\n\n    unsafe { write_volatile(reg, 1 << LED) }\n\n    // sleep\n    for _ in 0..5000 {\n        unsafe { asm!("nop") }\n    }\n}\n'})})]}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsxs)(n.li,{children:["Register an interrupt on the pin connected to button A. Toggle LED2 each time the button is pressed. (",(0,i.jsx)(n.strong,{children:"2p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Look at the table on the back of the Pico Explorer Base to figure out to which pin button A is connected."})}),"\n",(0,i.jsxs)(n.ol,{start:"5",children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"embassy-rs"})," to obtain the same result. (",(0,i.jsx)(n.strong,{children:"2p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Spawning a new task might be a good idea."})})]})}function h(e={}){const{wrapper:n}={...(0,s.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},37180:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/IRQrp2040-ae016aa4bd46728ca373d2658729e24d.png"},91344:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/M0regs-0eec2be5ea84b8c8430cdb991261f196.png"},11924:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/VectorTable_ARM_CortexM0-e0ca77fcbfd7a757f3c2ef6d85206986.png"},26780:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/embassy_irq-3d64afb551c444b331ae08517354d63b.png"},69408:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/embedded-hal-embassy-aa8d9068aeccfaa7a7ac7362146e9b4c.svg"},23668:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/flash_address-f6b4184a1da876a7e83752b2ff6e1d68.svg"},98932:(e,n,t)=>{t.d(n,{c:()=>i});const i="data:image/png;base64,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"},72660:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/rpsubsystem-8fa22f1ea9fa8ec9021a165ee2640150.png"},74748:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/stack_frame-0dc91615c2f2f0409a3df507e0086f49.png"},42220:(e,n,t)=>{t.d(n,{c:()=>i});const i=t.p+"assets/images/explorer_pins-826d67f02154207c1b67514ed209149a.jpg"},4552:(e,n,t)=>{t.d(n,{I:()=>l,M:()=>a});var i=t(11504);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);