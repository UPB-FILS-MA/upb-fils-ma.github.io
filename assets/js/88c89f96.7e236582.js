"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8152],{21028:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>d,default:()=>o,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var i=n(17624),t=n(4552);const r={sidebar_position:7,description:"Serial Peripheral Interface",slug:"/lab/06"},d="06 - Serial Peripheral Interface",l={id:"lab/06/index",title:"06 - Serial Peripheral Interface",description:"Serial Peripheral Interface",source:"@site/docs/lab/06/index.md",sourceDirName:"lab/06",slug:"/lab/06",permalink:"/docs/lab/06",draft:!1,unlisted:!1,editUrl:"https://github.com/UPB-FILS-MA/upb-fils-ma.github.io/edit/main/docs/lab/06/index.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,description:"Serial Peripheral Interface",slug:"/lab/06"},sidebar:"tutorialSidebar",previous:{title:"05 - Asynchronous Development",permalink:"/docs/lab/05"},next:{title:"07 - Inter-Integrated Circuit",permalink:"/docs/lab/07"}},a={},c=[{value:"Resources",id:"resources",level:2},{value:"Serial Peripheral Interface (SPI)",id:"serial-peripheral-interface-spi",level:2},{value:"Data transmission",id:"data-transmission",level:3},{value:"Transmission example",id:"transmission-example",level:4},{value:"SPI modes",id:"spi-modes",level:3},{value:"Daisy Chaining",id:"daisy-chaining",level:3},{value:"DMA",id:"dma",level:2},{value:"SPI in Embassy",id:"spi-in-embassy",level:2},{value:"Digital vs Analog sensors",id:"digital-vs-analog-sensors",level:2},{value:"Analog sensors",id:"analog-sensors",level:3},{value:"Digital sensors",id:"digital-sensors",level:3},{value:"BMP280 Digital Pressure Sensor",id:"bmp280-digital-pressure-sensor",level:2},{value:"BMP280 Memory Map",id:"bmp280-memory-map",level:3},{value:"Registers",id:"registers",level:4},{value:"BMP280 wiring",id:"bmp280-wiring",level:3},{value:"Reading the temperature/pressure from the BMP280 sensor using Embassy",id:"reading-the-temperaturepressure-from-the-bmp280-sensor-using-embassy",level:3},{value:"Reading a register",id:"reading-a-register",level:4},{value:"Writing to a register",id:"writing-to-a-register",level:4},{value:"Buzzer",id:"buzzer",level:3},{value:"Exercises",id:"exercises",level:2}];function h(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"06---serial-peripheral-interface",children:"06 - Serial Peripheral Interface"}),"\n",(0,i.jsx)(s.p,{children:"This lab will teach you how to communicate with hardware devices using the Serial Peripheral Interface (SPI) protocol, in Embassy."}),"\n",(0,i.jsx)(s.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Raspberry Pi Ltd"}),", ",(0,i.jsx)(s.em,{children:(0,i.jsx)(s.a,{href:"https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf",children:"RP2040 Datasheet"})})]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Chapter 4 - ",(0,i.jsx)(s.em,{children:"Peripherals"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Chapter 4.4 - ",(0,i.jsx)(s.em,{children:"SPI"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"BOSCH"}),", ",(0,i.jsx)(s.em,{children:(0,i.jsx)(s.a,{href:"https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bmp280-ds001.pdf",children:"BMP280 Digital Pressure Sensor"})})]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Chapter 3 - ",(0,i.jsx)(s.em,{children:"Functional Description"})]}),"\n",(0,i.jsxs)(s.li,{children:["Chapter 4 - ",(0,i.jsx)(s.em,{children:"Global memory map and register description"})]}),"\n",(0,i.jsxs)(s.li,{children:["Chapter 5 - ",(0,i.jsx)(s.em,{children:"Digital Interfaces"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Subchapter 5.3 - ",(0,i.jsx)(s.em,{children:"SPI Interface"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Paul Denisowski"}),", ",(0,i.jsx)(s.em,{children:(0,i.jsx)(s.a,{href:"https://www.youtube.com/watch?v=0nVNwozXsIc",children:"Understanding SPI"})})]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"serial-peripheral-interface-spi",children:"Serial Peripheral Interface (SPI)"}),"\n",(0,i.jsxs)(s.p,{children:["The Serial Peripheral Interface (or SPI) is a communication protocol used between microcontrollers and peripheral ICs (integrated circuits). It allows synchronous transfer of data between one ",(0,i.jsx)(s.em,{children:"main"})," device and one or more ",(0,i.jsx)(s.em,{children:"sub"})," devices (e.g. sensors). The main device is the one that dictates the communication."]}),"\n",(0,i.jsx)(s.h3,{id:"data-transmission",children:"Data transmission"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"SPI_protocol",src:n(8544).c+"",width:"691",height:"259"})}),"\n",(0,i.jsx)(s.p,{children:"SPI transmission usually uses 4 lines:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"CLK"})," - clock - generated by the main device - subs use it to synchronously read and write to the bus"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"MOSI"})," - ",(0,i.jsx)(s.strong,{children:"M"}),"ain ",(0,i.jsx)(s.strong,{children:"O"}),"ut ",(0,i.jsx)(s.strong,{children:"S"}),"ub ",(0,i.jsx)(s.strong,{children:"I"}),"n - used to carry data from the main device to ",(0,i.jsx)(s.em,{children:"all"})," the subs"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"MISO"})," - ",(0,i.jsx)(s.strong,{children:"M"}),"ain ",(0,i.jsx)(s.strong,{children:"I"}),"n ",(0,i.jsx)(s.strong,{children:"S"}),"ub ",(0,i.jsx)(s.strong,{children:"O"}),"ut - used to carry data from the ",(0,i.jsx)(s.em,{children:"active"})," sub to the main device"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"CS"})," - chip select - selects the sub to be activated, or the sub that the main wants to communicate with","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"one wire per sub"}),"\n",(0,i.jsxs)(s.li,{children:["inactive subs will disconnect from the ",(0,i.jsx)(s.em,{children:"MOSI"})," and ",(0,i.jsx)(s.em,{children:"MISO"})," lines"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsxs)(s.p,{children:["The communication is ",(0,i.jsx)(s.em,{children:"full-duplex"}),". This means that data is transmitted in both directions simultaneously. With that being said, during data transmission, both the main and the sub ",(0,i.jsx)(s.strong,{children:"must write"})," to the MOSI/MISO wires, no matter if that data is relevant or not."]})}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["SPI is most commonly implemented in a 4-wire configuration. However, there is also a 3-wire configuration, where the ",(0,i.jsx)(s.code,{children:"MOSI"})," and ",(0,i.jsx)(s.code,{children:"MISO"})," lines are common. This makes the communication ",(0,i.jsx)(s.em,{children:"half-duplex"}),", since data can be sent only in one direction at a time."]})}),"\n",(0,i.jsx)(s.h4,{id:"transmission-example",children:"Transmission example"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["main sets ",(0,i.jsx)(s.code,{children:"CS"})," to ",(0,i.jsx)(s.code,{children:"LOW"})," - the sub that the main wants to communicate with is activated - all other subs are already disconnected from ",(0,i.jsx)(s.code,{children:"MOSI"})," and ",(0,i.jsx)(s.code,{children:"MISO"})," lines as their CS line is not active"]}),"\n",(0,i.jsxs)(s.li,{children:["main writes the first bit on the ",(0,i.jsx)(s.code,{children:"MOSI"})," line, and, ",(0,i.jsx)(s.em,{children:"simultaneously"}),", sub writes the first bit on the ",(0,i.jsx)(s.code,{children:"MISO"})," line"]}),"\n",(0,i.jsx)(s.li,{children:"main starts the clock"}),"\n",(0,i.jsxs)(s.li,{children:["on ",(0,i.jsx)(s.em,{children:"rising edge"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["main reads data from the ",(0,i.jsx)(s.code,{children:"MISO"})," line"]}),"\n",(0,i.jsxs)(s.li,{children:["sub reads data from the ",(0,i.jsx)(s.code,{children:"MOSI"})," line"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["on ",(0,i.jsx)(s.em,{children:"falling edge"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["main writes data to the ",(0,i.jsx)(s.code,{children:"MOSI"})," line"]}),"\n",(0,i.jsxs)(s.li,{children:["sub writes data to the ",(0,i.jsx)(s.code,{children:"MISO"})," line"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.li,{children:"repeat steps 4 and 5 until main stops the clock"}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["Whether steps 4 and 5 happen on rising/falling edge depends on the ",(0,i.jsx)(s.code,{children:"CPOL"})," configuration of the SPI."]})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"SPI_example",src:n(87268).c+"",width:"1000",height:"210"})}),"\n",(0,i.jsxs)(s.p,{children:["In the image above, the main first exchanges data with the first sub by setting its corresponding ",(0,i.jsx)(s.code,{children:"CS"})," line to low. After it finishes transmission with sub 1, it deactivates it and, afterwards, initiates communication with the second sub by setting its ",(0,i.jsx)(s.code,{children:"CS"})," line to low. Notice that both main and sub read and write to the MOSI/MISO line simultaneously."]}),"\n",(0,i.jsx)(s.h3,{id:"spi-modes",children:"SPI modes"}),"\n",(0,i.jsxs)(s.p,{children:["SPI has 4 different modes which define when data is read or written. These modes can be configured through 2 registers: ",(0,i.jsx)(s.code,{children:"CPOL"})," and ",(0,i.jsx)(s.code,{children:"CPHA"}),"."]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Mode"}),(0,i.jsx)(s.th,{children:(0,i.jsx)(s.code,{children:"CPOL"})}),(0,i.jsx)(s.th,{children:(0,i.jsx)(s.code,{children:"CPHA"})}),(0,i.jsx)(s.th,{children:"Clock polarity in idle state"}),(0,i.jsx)(s.th,{children:"Clock phase used to read and/or write data"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"0"}),(0,i.jsx)(s.td,{children:"0"}),(0,i.jsx)(s.td,{children:"0"}),(0,i.jsx)(s.td,{children:"Logic Low"}),(0,i.jsx)(s.td,{children:"Data read on rising edge and written on falling edge"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"1"}),(0,i.jsx)(s.td,{children:"0"}),(0,i.jsx)(s.td,{children:"1"}),(0,i.jsx)(s.td,{children:"Logic low"}),(0,i.jsx)(s.td,{children:"Data read on the falling edge and written on the rising edge"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"2"}),(0,i.jsx)(s.td,{children:"1"}),(0,i.jsx)(s.td,{children:"0"}),(0,i.jsx)(s.td,{children:"Logic high"}),(0,i.jsx)(s.td,{children:"Data read on the falling edge and written on the rising edge"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"3"}),(0,i.jsx)(s.td,{children:"1"}),(0,i.jsx)(s.td,{children:"1"}),(0,i.jsx)(s.td,{children:"Logic high"}),(0,i.jsx)(s.td,{children:"Data read on the rising edge and written on the falling edge"})]})]})]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{}),(0,i.jsx)(s.th,{}),(0,i.jsx)(s.th,{})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"CPOL"})}),(0,i.jsx)(s.td,{children:"Clock polarity"}),(0,i.jsxs)(s.td,{children:["defines when the clock is considered ",(0,i.jsx)(s.em,{children:"idle"}),", or when no transfer is occurring"]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"CPHA"})}),(0,i.jsx)(s.td,{children:"Clock phase"}),(0,i.jsxs)(s.td,{children:["defines when the data bit is read and when it is written: depends on ",(0,i.jsx)(s.code,{children:"CPOL"})]})]})]})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"SPI_timing_diagram",src:n(9788).c+"",width:"590",height:"270"})}),"\n",(0,i.jsx)(s.h3,{id:"daisy-chaining",children:"Daisy Chaining"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Daisy chaining"})," is an SPI configuration through which the sub devices are linked together as such:"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"SPI_Daisy",src:n(95952).c+"",width:"691",height:"249"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"MOSI"})," line connects the main device only to the first sub. Then, the ",(0,i.jsx)(s.code,{children:"MISO"})," output of the first sub ties to the ",(0,i.jsx)(s.code,{children:"MOSI"})," input of the second sub, and so forth. The final sub in the chain ties to the ",(0,i.jsx)(s.code,{children:"MISO"})," line of the main device. All ",(0,i.jsx)(s.code,{children:"CS"})," lines are common, therefore all subs are always active."]}),"\n",(0,i.jsx)(s.p,{children:"For example, if main wants to communicate with the second sub, it will:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["send its data through the ",(0,i.jsx)(s.code,{children:"MOSI"})," line to the first sub"]}),"\n",(0,i.jsx)(s.li,{children:"the first sub will send the data to the second sub, through the common wire"}),"\n",(0,i.jsx)(s.li,{children:"once the second sub receives the data, it will send its response to the third sub"}),"\n",(0,i.jsxs)(s.li,{children:["at the end of the chain, the last sub will send the data back to the main device through the ",(0,i.jsx)(s.code,{children:"MISO"})," line"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"dma",children:"DMA"}),"\n",(0,i.jsxs)(s.p,{children:["When it comes to standard communication protocols that rely on ",(0,i.jsx)(s.a,{href:"/docs/lab/02",children:"MMIO"}),", it would be inefficient to rely on the MCU itself to handle all of these data transfers. This is why the ",(0,i.jsx)(s.strong,{children:"Direct Memory Access"})," (DMA) is used. Its purpose is to offload the MCU by dealing with simple transmission to and from peripherals, and whenever it finishes a transfer, it raises an interrupt."]}),"\n",(0,i.jsx)(s.h2,{id:"spi-in-embassy",children:"SPI in Embassy"}),"\n",(0,i.jsx)(s.p,{children:"In Embassy, we can use the SPI both blocking and asynchronously. The following example will be using the asynchronous version."}),"\n",(0,i.jsx)(s.admonition,{type:"warning",children:(0,i.jsxs)(s.p,{children:["The SPI can also be used synchronously, but this means that for every transfer, the thread will be blocked, as we found out in the ",(0,i.jsx)(s.a,{href:"/docs/lab/05",children:"previous lab"}),"."]})}),"\n",(0,i.jsx)(s.p,{children:"First, we initialize the peripherals."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"let peripherals = embassy_rp::init(Default::default());\n"})}),"\n",(0,i.jsx)(s.p,{children:"Next, we create the configuration for the SPI. We can set the clock frequency, polarity and phase (the SPI mode)."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"let mut config = spi::Config::default();\nconfig.frequency = 2_000_000;\nconfig.phase = spi::Phase::CaptureOnFirstTransition;\nconfig.polarity = spi::Polarity::IdleHigh;\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Once we have the configuration, we can initialize the ",(0,i.jsx)(s.code,{children:"MISO"}),", ",(0,i.jsx)(s.code,{children:"MOSI"})," and ",(0,i.jsx)(s.code,{children:"CLK"})," pins."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"let miso = peripherals.PIN_X;\nlet mosi = peripherals.PIN_Y;\nlet clk = peripherals.PIN_Z;\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Now we can create our SPI instance. The example uses the SPI0 channel, but others can be used. Being an asynchronous SPI, it also needs a pair of ",(0,i.jsx)(s.code,{children:"DMA"})," channels, one that handles the ",(0,i.jsx)(s.em,{children:"transmission"})," of data, and one that handles the ",(0,i.jsx)(s.em,{children:"receiving"})," of data."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"let mut spi = Spi::new(peripherals.SPI0, clk, mosi, miso, peripherals.DMA_CH0, peripherals.DMA_CH1, config);\n"})}),"\n",(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsx)(s.p,{children:"To figure out which pins work with SPI and what channels they are associated with, you need to take a look at the pinout of the Raspberry Pi Pico."})}),"\n",(0,i.jsxs)(s.p,{children:["We also need a ",(0,i.jsx)(s.code,{children:"CS"})," pin, that is simply a GPIO output pin. We will initialize it as such. Any pin can be used. For multiple subs, multiple pins will be initialized."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"let mut cs = Output::new(peripherals.PIN_N, Level::High);\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Now we have set up the SPI, and can use it to communicate with the connected sub. To activate the sub, we need to set the ",(0,i.jsx)(s.code,{children:"cs"})," pin to ",(0,i.jsx)(s.code,{children:"low"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"cs.set_low();\n"})}),"\n",(0,i.jsx)(s.p,{children:"Once we do this, we can use two buffers:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"tx_buf"})," - used to store data to transmit to the sub via the ",(0,i.jsx)(s.code,{children:"MOSI"})," line"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"rx_buf"})," - one to store data to receive from the sub via the ",(0,i.jsx)(s.code,{children:"MISO"})," line"]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"let tx_buf = [1_u8, 2, 3, 4, 5, 6];\nlet mut rx_buf = [0_u8; 6]; // dummy values, will be replaced by received data\n"})}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"rx_buf"})," is mutable because the values inside the buffer will be replaced by the data received from the sub."]})}),"\n",(0,i.jsxs)(s.p,{children:["We then use the two buffers to make the transfer. The values in ",(0,i.jsx)(s.code,{children:"tx_buffer"})," will be sent over the ",(0,i.jsx)(s.code,{children:"MOSI"})," and the values received over the ",(0,i.jsx)(s.code,{children:"MISO"})," will be stored in ",(0,i.jsx)(s.code,{children:"rx_buf"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"spi.transfer(&mut rx_buf, &tx_buf).await;\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Once we are done with the transfer, we set the ",(0,i.jsx)(s.code,{children:"cs"})," line back to ",(0,i.jsx)(s.code,{children:"high"})," to deactivate the sub."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"cs.set_high();\n"})}),"\n",(0,i.jsx)(s.h2,{id:"digital-vs-analog-sensors",children:"Digital vs Analog sensors"}),"\n",(0,i.jsx)(s.h3,{id:"analog-sensors",children:"Analog sensors"}),"\n",(0,i.jsxs)(s.p,{children:["Up to now, during the labs, we have been using ",(0,i.jsx)(s.em,{children:"analog sensors"})," (photoresistor and potentiometer). Analog sensors are just a transducer, which outputs a voltage depending on its measurement (light, temperature, etc.). This output needs to be read using an ADC and processed so that it can resemble something useful to us."]}),"\n",(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsx)(s.p,{children:"For example, for an analog temperature sensor, we would be getting a voltage reading that we need to convert to an actual temperature in Celsius by using a specific formula. This formula can usually be found in the datasheet of the analog sensor."})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Analog_Sensor",src:n(79616).c+"",width:"169",height:"96"})}),"\n",(0,i.jsx)(s.h3,{id:"digital-sensors",children:"Digital sensors"}),"\n",(0,i.jsxs)(s.p,{children:["For this lab, we will be using a ",(0,i.jsx)(s.em,{children:"digital sensor"}),", which is an ",(0,i.jsx)(s.em,{children:"upgraded"})," version of an analog sensor. It contains a transducer, but also an internal MCU with an ADC. This means that the sensor itself deals with the analog-to-digital conversion and the processing of the voltage reading, and exposes it through a digital interface of registers that can be accessed using a specific communication protocol (e.g. SPI, I2C etc.)."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Digital_Sensor",src:n(85736).c+"",width:"401",height:"112"})}),"\n",(0,i.jsx)(s.h2,{id:"bmp280-digital-pressure-sensor",children:"BMP280 Digital Pressure Sensor"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.strong,{children:"BMP280"})," is a ",(0,i.jsx)(s.em,{children:"digital"})," temperature and pressure sensor designed by Bosch. It can be interfaced both with SPI and with I2C. This means that we can read the temperature and pressure values directly from the registers of the BMP280 using SPI."]}),"\n",(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"DATASHEET"}),": ",(0,i.jsx)(s.a,{href:"https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bmp280-ds001.pdf",children:"https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bmp280-ds001.pdf"})]})}),"\n",(0,i.jsx)(s.h3,{id:"bmp280-memory-map",children:"BMP280 Memory Map"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"BMP280_Memory_Map",src:n(36896).c+"",width:"1266",height:"449"})}),"\n",(0,i.jsx)(s.h4,{id:"registers",children:"Registers"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"id"})," register - contains the ID of the BMP280"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"ctrl_meas"})," register - used for configuring the temperature/pressure measurements of the sensor"]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.th,{children:[(0,i.jsx)(s.code,{children:"ctrl_meas"})," bits"]}),(0,i.jsx)(s.th,{children:"Name"}),(0,i.jsx)(s.th,{children:"Description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"Bit 7, 6, 5"}),(0,i.jsx)(s.td,{children:"osrs_t[2:0]"}),(0,i.jsx)(s.td,{children:"Controls oversampling of temperature data."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"Bit 4, 3, 2"}),(0,i.jsx)(s.td,{children:"osrs_p[2:0]"}),(0,i.jsx)(s.td,{children:"Controls oversampling of pressure data."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"Bit 1, 0"}),(0,i.jsx)(s.td,{children:"mode[1:0]"}),(0,i.jsx)(s.td,{children:"Controls the power mode of the device."})]})]})]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"osrs_p[2:0]"}),(0,i.jsx)(s.th,{children:"Pressure oversampling"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"000"}),(0,i.jsx)(s.td,{children:"Skipped (output set to 0x80000)"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"001"}),(0,i.jsx)(s.td,{children:"oversampling x 1"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"010"}),(0,i.jsx)(s.td,{children:"oversampling x 2"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"011"}),(0,i.jsx)(s.td,{children:"oversampling x 4"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"100"}),(0,i.jsx)(s.td,{children:"oversampling x 8"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"101, others"}),(0,i.jsx)(s.td,{children:"oversampling x 16"})]})]})]}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"osrs_t[2:0]"}),(0,i.jsx)(s.th,{children:"Temperature oversampling"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"000"}),(0,i.jsx)(s.td,{children:"Skipped (output set to 0x80000)"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"001"}),(0,i.jsx)(s.td,{children:"oversampling x 1"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"010"}),(0,i.jsx)(s.td,{children:"oversampling x 2"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"011"}),(0,i.jsx)(s.td,{children:"oversampling x 4"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"100"}),(0,i.jsx)(s.td,{children:"oversampling x 8"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"101, others"}),(0,i.jsx)(s.td,{children:"oversampling x 16"})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"press"})," registers - ",(0,i.jsx)(s.code,{children:"press_msb"}),", ",(0,i.jsx)(s.code,{children:"press_lsb"}),", ",(0,i.jsx)(s.code,{children:"press_xslb"})," - contain the pressure measurement"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"temp"})," registers - ",(0,i.jsx)(s.code,{children:"temp_msb"}),", ",(0,i.jsx)(s.code,{children:"temp_lsb"}),", ",(0,i.jsx)(s.code,{children:"temp_xslb"})," - contain the temperature measurement"]}),"\n",(0,i.jsx)(s.admonition,{type:"warning",children:(0,i.jsxs)(s.p,{children:["Unless we write to the ",(0,i.jsx)(s.code,{children:"osrs_p"})," and ",(0,i.jsx)(s.code,{children:"osrs_t"})," fields of the ",(0,i.jsx)(s.code,{children:"ctrl_meas"})," register, the ",(0,i.jsx)(s.code,{children:"press"})," and ",(0,i.jsx)(s.code,{children:"temp"})," registers will have a constant value of ",(0,i.jsx)(s.code,{children:"0x80000"}),"! We need to configure the pressure and temperature oversampling before reading the measurements."]})}),"\n",(0,i.jsx)(s.h3,{id:"bmp280-wiring",children:"BMP280 wiring"}),"\n",(0,i.jsx)(s.p,{children:"The BMP280 has 5 pins:"}),"\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"Pin"}),(0,i.jsx)(s.th,{children:"Function"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"VCC"})}),(0,i.jsx)(s.td,{children:"power source (3V3)"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"GND"})}),(0,i.jsx)(s.td,{children:"ground"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"SCL"})}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"CLK"})," line"]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"SDA"})}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"MOSI"})," line"]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"CSB"})}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"CS"})," line"]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:(0,i.jsx)(s.code,{children:"SDO"})}),(0,i.jsxs)(s.td,{children:[(0,i.jsx)(s.code,{children:"MISO"})," line"]})]})]})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"bmp280_wiring",src:n(1112).c+"",width:"448",height:"345"})}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsx)(s.p,{children:"The BMP280 can also be interfaced through I2C, using the same pins but with different functions."})}),"\n",(0,i.jsxs)(s.p,{children:["The Raspberry Pi Pico has two usable SPI channels: SPI0 and SPI1. Each channel has two sets of pins that can be used for ",(0,i.jsx)(s.code,{children:"CLK"}),", ",(0,i.jsx)(s.code,{children:"MOSI"})," and ",(0,i.jsx)(s.code,{children:"MISO"}),". They are marked with pink in the pinout diagram."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"pico_pinout",src:n(1397).c+"",width:"1063",height:"835"})}),"\n",(0,i.jsxs)(s.admonition,{type:"info",children:[(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"TX"})," = transmitter = ",(0,i.jsx)(s.code,{children:"MOSI"})]}),(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"RX"})," = receiver = ",(0,i.jsx)(s.code,{children:"MISO"})]})]}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsx)(s.p,{children:"Since we are using the Pico Explorer, it's simple to see which pins are used for SPI transmission. You can also check the back side of the Pico Explorer to see exactly which GP pins are being used by the extension for SPI."})}),"\n",(0,i.jsx)(s.h3,{id:"reading-the-temperaturepressure-from-the-bmp280-sensor-using-embassy",children:"Reading the temperature/pressure from the BMP280 sensor using Embassy"}),"\n",(0,i.jsxs)(s.p,{children:["To get the temperature and pressure values we want from the digital sensor, we need to access its internal registers. The BMP280 has some rules when it comes to reading and writing to these registers, that must be extracted from the ",(0,i.jsx)(s.a,{href:"https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bmp280-ds001.pdf",children:"datasheet"}),". Every sensor has different registers, and different ways of interfacing them, so reading the datasheet is usually required, especially when we don't have the leverage of using already existing libraries for these sensors."]}),"\n",(0,i.jsx)(s.p,{children:"First, we make sure our SPI is initialized correctly."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"let peripherals = embassy_rp::init(Default::default());\n\nlet mut config = spi::Config::default();\nconfig.frequency = 2_000_000;\n// default values for phase and polarity are fine\n\nlet miso = peripherals.PIN_X;\nlet mosi = peripherals.PIN_Y;\nlet clk = peripherals.PIN_Z;\n// make sure you use a SPI channel that supports the miso, mosi and clk pin numbers you chose!\nlet mut spi = Spi::new(peripherals.SPI0, clk, mosi, miso, peripherals.DMA_CH0, peripherals.DMA_CH1, config);\n\nlet mut cs = Output::new(peripherals.PIN_N, Level::High);\n"})}),"\n",(0,i.jsx)(s.p,{children:"In section 5.3.2 of the datasheet, we get the information we need in order to read/write to a register of the BMP280."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"SPI_read_write_BMP280",src:n(55372).c+"",width:"1593",height:"494"})}),"\n",(0,i.jsxs)(s.p,{children:["To know what is expected from it, the sensor needs to receive a ",(0,i.jsx)(s.em,{children:"control byte"}),". This control byte contains the address of the register that we want to access, except the 7th bit of this address is changed:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["it will be ",(0,i.jsx)(s.code,{children:"1"})," if we want to ",(0,i.jsx)(s.em,{children:"read"})," the register"]}),"\n",(0,i.jsxs)(s.li,{children:["it will be ",(0,i.jsx)(s.code,{children:"0"})," if we want to ",(0,i.jsx)(s.em,{children:"write"})," to the register"]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["So, for example, if we wanted to read the register at address 0x1, we would need to send a control byte of ",(0,i.jsx)(s.code,{children:"10000001"}),", and if we wanted to write to it, we would send ",(0,i.jsx)(s.code,{children:"00000001"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"This way, we're sending a command to the sensor for it to know what to do: either send back the value of the register we requested or write to this register."}),"\n",(0,i.jsx)(s.h4,{id:"reading-a-register",children:"Reading a register"}),"\n",(0,i.jsxs)(s.p,{children:["To read the value of a register, the main device (the RP2040) needs to first send a control byte containing the address of that register, with the 7th bit a ",(0,i.jsx)(s.code,{children:"1"}),".\nThe sub device (the sensor) will then send a byte back, containing the value of the requested register."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"cs.set_low();\nlet tx_buf = [(1 << 7) | REG_ADDR, 0x00]; // first value of buffer is the control byte, second is a *don't care* value\nlet mut rx_buf = [0u8; 2]; // initial values that will be replaced by the received bytes\nspi.transfer(&mut rx_buf, &tx_buf).await;\ncs.set_high();\nlet register_value = rx_buf[1]; // the second byte in the buffer will be the received register value\n"})}),"\n",(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsxs)(s.p,{children:["Remember, SPI is full-duplex. When the main writes, the sub also writes, no matter if it has any relevant data to send or not. This is why the ",(0,i.jsx)(s.code,{children:"tx_buf"})," and ",(0,i.jsx)(s.code,{children:"rx_buf"})," both have 2 elements. First, the main will send the register address (",(0,i.jsx)(s.code,{children:"tx_buf[0]"}),") and the sub will send a dummy value back (stored in ",(0,i.jsx)(s.code,{children:"rx_buf[0]"}),"), ",(0,i.jsx)(s.em,{children:"at the same time"}),". Then, the main will send a dummy value (",(0,i.jsx)(s.code,{children:"tx_buf[1]"}),") and the sub will send the value of the register (stored in ",(0,i.jsx)(s.code,{children:"rx_buf[1]"}),")."]})}),"\n",(0,i.jsxs)(s.admonition,{type:"tip",children:[(0,i.jsxs)(s.p,{children:["Once we send the address of a register we want to read, the sensor will continuously send back bytes containing the values of the consecutive registers. For example, if we ask to read ",(0,i.jsx)(s.code,{children:"REG_ADDR"}),", the sensor will first send the register value at address ",(0,i.jsx)(s.code,{children:"REG_ADDR"}),", then the value at address ",(0,i.jsx)(s.code,{children:"REG_ADDR+1"}),", and so on, until we deactivate it."]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"cs.set_low();\nlet tx_buf = [(1 << 7) | REG_ADDR, 0x00, 0x00];\nlet mut rx_buf = [0u8; 3]; // three receive values instead of two\nspi.transfer(&mut rx_buf, &tx_buf).await;\ncs.set_high();\nlet register_value = rx_buf[1]; // the second byte in the buffer will be the received register value (REG_ADDR)\nlet register_value_next = rx_buf[2]; // the third byte in the buffer will be the next received register value (REG_ADDR+1)\n"})}),(0,i.jsx)(s.p,{children:"This is explained in section 5.3 of the datasheet."})]}),"\n",(0,i.jsx)(s.h4,{id:"writing-to-a-register",children:"Writing to a register"}),"\n",(0,i.jsxs)(s.p,{children:["To write a value to a register, the main device (the RP2040) needs to first send a control byte containing the address of that register, with the 7th bit a ",(0,i.jsx)(s.code,{children:"0"}),".\nThe main device then must send the value that it wants to write to that register."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"cs.set_low();\nlet tx_buf = [!(1 << 7) & REG_ADDR, value_to_write]; // value_to_write is to be replaced with the 8-bit value that we want to write to this register\nlet mut rx_buf = [0u8; 2]; // we are not expecting any relevant information to be received, but we still need to receive dummy values anyway\nspi.transfer(&mut rx_buf, &tx_buf).await;\n"})}),"\n",(0,i.jsx)(s.h3,{id:"buzzer",children:"Buzzer"}),"\n",(0,i.jsx)(s.p,{children:"A buzzer is a hardware device that emits sound. There are two types of buzzers:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"active buzzer"})," - connected to VCC and GND, with a resistance - emits a constant frequency"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"passive buzzer"})," - connected to a GPIO pin and GND, with a resistance - frequency can be controlled through the pin with PWM"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Buzzer",src:n(96384).c+"",width:"327",height:"327"})}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsxs)(s.p,{children:["To control the buzzer, all you need to do is to set the ",(0,i.jsx)(s.code,{children:"top"})," value of the PWM config to match the frequency you want!"]})}),"\n",(0,i.jsx)(s.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["Connect the BMP280. Use the wiring configuration for the SPI, and connect the CS to GPIO 3. Next, connect the buzzer (with a resistance) to GPIO 1. Use Kicad to draw the schematic. (",(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["The example provided for exercise 2 in the lab skeleton is a basic example of how to read a register of the BMP280. Modify it to read the ",(0,i.jsx)(s.code,{children:"id"})," of the BMP280 and print it over serial. (",(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsxs)(s.p,{children:["Use the datasheet to find the address of the ",(0,i.jsx)(s.code,{children:"id"})," register! Take a look at section 4.2 and 4.3."]})}),"\n",(0,i.jsxs)(s.ol,{start:"3",children:["\n",(0,i.jsx)(s.li,{children:"Get the pressure and temperature readings from the sensor."}),"\n"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Write the ",(0,i.jsx)(s.code,{children:"ctrl_meas"})," register with appropriate configuration values. You can find information on the contents you should write to this register at section 4.3.4 of the datasheet. (",(0,i.jsx)(s.strong,{children:"2p"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["Read the raw pressure value and print it over the serial. (",(0,i.jsx)(s.strong,{children:"2p"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(s.admonition,{type:"tip",children:[(0,i.jsxs)(s.p,{children:["The pressure value is split into 3 registers: ",(0,i.jsx)(s.code,{children:"press_msb"}),", ",(0,i.jsx)(s.code,{children:"press_lsb"})," and ",(0,i.jsx)(s.code,{children:"press_xlsb"}),"."]}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"press_msb"})," is the first binary half of the pressure value (stands for pressure most significant bits)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"press_lsb"})," is the second binary half of the pressure value (stands for pressure least significant bits)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"press_xlsb"})," is an extra degree of precision for the pressure value, depends on the oversampling value written to the ",(0,i.jsx)(s.code,{children:"ctrl_meas"})," register"]}),"\n"]}),(0,i.jsxs)(s.p,{children:["To compute the ",(0,i.jsx)(s.strong,{children:"RAW"})," pressure value, we need to read ",(0,i.jsx)(s.code,{children:"press_msb"}),", ",(0,i.jsx)(s.code,{children:"press_lsb"})," and ",(0,i.jsx)(s.code,{children:"press_xlsb"})," and reconstruct the 20-bit pressure register, as such:"]}),(0,i.jsx)(s.p,{children:(0,i.jsx)(s.code,{children:"pressure = (press_msb << 12) + (press_lsb << 4) + (press_xlsb >> 4)"})})]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Read the raw temperature value and print it over the serial. (",(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsx)(s.p,{children:"This is similar to how we read the pressure value."})}),"\n",(0,i.jsxs)(s.ol,{start:"4",children:["\n",(0,i.jsxs)(s.li,{children:["Use the buzzer to make a sound if the temperature read from the sensor goes over a certain value. (",(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsx)(s.p,{children:"Use the buzzer with PWM for a specific sound frequency."})}),"\n",(0,i.jsxs)(s.admonition,{type:"warning",children:[(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"press"})," and",(0,i.jsx)(s.code,{children:"temp"})," registers contain the ",(0,i.jsx)(s.em,{children:"raw"})," value of the pressure and temperature. To compute the pressure in Pascals and the temperature in Celsius, we need to apply a specific formula based on the internal calibration data of the sensor. For simplicity, we have already provided you with the necessary function to do compute the temperature value in the lab skeleton."]}),(0,i.jsxs)(s.p,{children:["The value returned by the ",(0,i.jsx)(s.code,{children:"calculate_temperature"})," function is: ",(0,i.jsx)(s.code,{children:"actual_temp * 100"}),"."]}),(0,i.jsx)(s.p,{children:"The formula for the actual pressure value can be found at section 3.11 of the datasheet."})]}),"\n",(0,i.jsxs)(s.ol,{start:"5",children:["\n",(0,i.jsx)(s.li,{children:"Show the temperature and pressure values on the screen. The screen also uses SPI."}),"\n"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Move the sensor to the second SPI channel (SPI1). Change the wiring and code accordingly. The two SPI devices will work independently on different channels. (",(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(s.admonition,{type:"warning",children:(0,i.jsx)(s.p,{children:'The SPI1 channel is accessible on the Pico Explorer by using the pins marked as "motor".'})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Use both the sensor and the screen on the same SPI channel. This means that the two devices will be subs in the same common configuration, and therefore will use the same CLK, MOSI and MISO pins, with separate CS. (",(0,i.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(s.admonition,{type:"tip",children:[(0,i.jsxs)(s.p,{children:["For this, we will need to initialize the sensor to use the same SPI bus as the screen. For this, we can use an Embassy driver called ",(0,i.jsx)(s.code,{children:"SpiDeviceWithConfig"}),", which will allow us to connect both the screen and the sensor in the same SPI configuration! Since the screen is already using a blocking SPI, we will use it when creating our SPI sensor device, like this:"]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"let mut spi: Spi<'_, _, Blocking> = Spi::new_blocking(peripherals.SPI0, clk, mosi, miso, bmp280_config.clone()); // SPI used by the display\nlet spi_bus: Mutex<NoopRawMutex, _> = Mutex::new(RefCell::new(spi)); // a SPI bus Mutex that will be shared by the two sub devices\n\nlet display_spi = SpiDeviceWithConfig::new(\n        &spi_bus,\n        display_cs,\n        display_config,\n    );\n\nlet mut bmp280_spi = SpiDeviceWithConfig::new(\n    &spi_bus,\n    bmp280_cs,\n    bmp280_config,\n);\n\n// ...display configurations and initialization...\n\nbmp280_spi.transfer(&mut rx_buf, &tx_buf);\n"})})]})]})}function o(e={}){const{wrapper:s}={...(0,t.M)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},79616:(e,s,n)=>{n.d(s,{c:()=>i});const i="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNjlweCIgaGVpZ2h0PSI5NnB4IiB2aWV3Qm94PSItMC41IC0wLjUgMTY5IDk2Ij48ZGVmcy8+PGc+PGcvPjxnPjxwYXRoIGQ9Ik0gMTAwIDQ3LjUgTCAxMzAgNDcuNSBMIDE1My42MyA0Ny41MSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzNhM2E0IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48cGF0aCBkPSJNIDE1OC44OCA0Ny41MSBMIDE1MS44OCA1MS4wMSBMIDE1My42MyA0Ny41MSBMIDE1MS44OCA0NC4wMSBaIiBmaWxsPSIjNzNhM2E0IiBzdHJva2U9IiM3M2EzYTQiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjwvZz48Zz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiIHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFweDsgcGFkZGluZy10b3A6IDMwcHg7IG1hcmdpbi1sZWZ0OiAxMzBweDsiPjxkaXYgc3R5bGU9ImJveC1zaXppbmc6IGJvcmRlci1ib3g7IGZvbnQtc2l6ZTogMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBkYXRhLWRyYXdpby1jb2xvcnM9ImNvbG9yOiByZ2IoMCwgMCwgMCk7IGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUsIDI1NSwgMjU1KTsgIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMTFweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigwLCAwLCAwKTsgbGluZS1oZWlnaHQ6IDEuMjsgcG9pbnRlci1ldmVudHM6IGFsbDsgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyB3aGl0ZS1zcGFjZTogbm93cmFwOyI+PGRpdj5Wb2x0YWdlwqA8L2Rpdj48ZGl2Pk91dHB1dDwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSIxMzAiIHk9IjMzIiBmaWxsPSJyZ2IoMCwgMCwgMCkiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTFweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+Vm9sdGFnZS4uLjwvdGV4dD48L3N3aXRjaD48L2c+PC9nPjxnPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iOTUiIHJ4PSIxNC4yNSIgcnk9IjE0LjI1IiBmaWxsPSIjZjVmNWY1IiBzdHJva2U9IiM2NjY2NjYiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48L2c+PGc+PGltYWdlIHg9IjQuNSIgeT0iMiIgd2lkdGg9IjkwIiBoZWlnaHQ9IjkwIiB4bGluazpocmVmPSJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJR1pwYkd3OUltNXZibVVpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2FHVnBaMmgwUFNJNE1EQndlQ0lnZDJsa2RHZzlJamd3TUhCNElqNG1JM2hoT3p4d1lYUm9JSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxZMkZ3UFNKeWIzVnVaQ0lnYzNSeWIydGxMWGRwWkhSb1BTSXlJaUJ6ZEhKdmEyVTlJaU13TURBd01EQWlJR1E5SWswNExqUTJORFEzSURFMUxqVXpOVFZETmk0MU1URTROU0F4TXk0MU9ESTVJRFl1TlRFeE9EVWdNVEF1TkRFM01TQTRMalEyTkRRM0lEZ3VORFkwTkRkTk5TNDJNelU1TWlBeE9DNHpOalJETWk0eE1qRXlJREUwTGpnME9UTWdNaTR4TWpFeUlEa3VNVFV3TnpjZ05TNDJNelU1TWlBMUxqWXpOakExVFRFMUxqVXpOVFVnTVRVdU5UTTFOVU14Tnk0ME9EZ3hJREV6TGpVNE1qa2dNVGN1TkRnNE1TQXhNQzQwTVRjeElERTFMalV6TlRVZ09DNDBOalEwTjAweE9DNHpOalFnTVRndU16WTBRekl4TGpnM09EZ2dNVFF1T0RRNU15QXlNUzQ0TnpnNElEa3VNVFV3TnpjZ01UZ3VNelkwSURVdU5qTTJNRFZOTVRNZ01USXVNREF3TVVNeE15QXhNaTQxTlRJeklERXlMalUxTWpNZ01UTXVNREF3TVNBeE1pQXhNeTR3TURBeFF6RXhMalEwTnpjZ01UTXVNREF3TVNBeE1TQXhNaTQxTlRJeklERXhJREV5TGpBd01ERkRNVEVnTVRFdU5EUTNPQ0F4TVM0ME5EYzNJREV4TGpBd01ERWdNVElnTVRFdU1EQXdNVU14TWk0MU5USXpJREV4TGpBd01ERWdNVE1nTVRFdU5EUTNPQ0F4TXlBeE1pNHdNREF4V2lJdlBpWWplR0U3UEM5emRtYysiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiLz48L2c+PC9nPjxzd2l0Y2g+PGcgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ii8+PGEgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwtNSkiIHhsaW5rOmhyZWY9Imh0dHBzOi8vd3d3LmRyYXdpby5jb20vZG9jL2ZhcS9zdmctZXhwb3J0LXRleHQtcHJvYmxlbXMiIHRhcmdldD0iX2JsYW5rIj48dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LXNpemU9IjEwcHgiIHg9IjUwJSIgeT0iMTAwJSI+VGV4dCBpcyBub3QgU1ZHIC0gY2Fubm90IGRpc3BsYXk8L3RleHQ+PC9hPjwvc3dpdGNoPjwvc3ZnPg=="},36896:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/bmp280_memory_map-ca5d36fc76cb82d93569bfc41969cb9c.png"},1112:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/bmp280_wiring-a336c808ebbdf7855650285161a767ae.png"},96384:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/buzzer-d17a0a1976fed5a42c3c7ffa0edb36f2.png"},85736:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/digital_sensor-091792696ba992aff298fd20483bc061.svg"},1397:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/pico_pinout-ef797f238902474e0c7c493dca354021.png"},95952:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/spi_daisy-5a73293643c13ccb3a7137871dd083cf.svg"},8544:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/spi_network-2dfbfa43885de34ead2d66cb1fe9efcf.svg"},87268:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/spi_network_transmission-0ac8016c74bf24a77c7d7cb6097fe868.svg"},55372:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/spi_read_write_bmp280-f0222ae81af706cb7f5267e58375c898.png"},9788:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/spi_variants-7a5d3abadeee766cae32471c6b2d50b3.svg"},4552:(e,s,n)=>{n.d(s,{I:()=>l,M:()=>d});var i=n(11504);const t={},r=i.createContext(t);function d(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);