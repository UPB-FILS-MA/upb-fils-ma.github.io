"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5832],{25065:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"tutorial/embassy/index","title":"Embassy-rs Setup","description":"How to install the prerequisites for embassy-rs","source":"@site/versioned_docs/version-acs_cc/tutorial/embassy/index.md","sourceDirName":"tutorial/embassy","slug":"/tutorials/embassy","permalink":"/docs/acs_cc/tutorials/embassy","draft":false,"unlisted":false,"editUrl":"https://github.com/UPB-FILS-MA/upb-fils-ma.github.io/edit/main/versioned_docs/version-acs_cc/tutorial/embassy/index.md","tags":[],"version":"acs_cc","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"slug":"/tutorials/embassy","description":"How to install the prerequisites for embassy-rs"},"sidebar":"tutorialSidebar","previous":{"title":"KiCad setup","permalink":"/docs/acs_cc/tutorial/kicad"}}');var i=s(74848),t=s(28453);const o={sidebar_position:2,slug:"/tutorials/embassy",description:"How to install the prerequisites for embassy-rs"},l="Embassy-rs Setup",a={},d=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Rust Toolchain",id:"rust-toolchain",level:3},{value:"Linux",id:"linux",level:4},{value:"Windows",id:"windows",level:4},{value:"<code>elf2uf2-rs</code>",id:"elf2uf2-rs",level:3},{value:"<code>probe-rs</code>",id:"probe-rs",level:3},{value:"VSCode Extension (Optional)",id:"vscode-extension-optional",level:3},{value:"Flashing over USB",id:"flashing-over-usb",level:2},{value:"Compiling",id:"compiling",level:3},{value:"Flashing",id:"flashing",level:3},{value:"Debugging using Raspberry Pi Debug Probe",id:"debugging-using-raspberry-pi-debug-probe",level:2},{value:"Building your first Embassy-rs project",id:"building-your-first-embassy-rs-project",level:2},{value:"Creating your crate",id:"creating-your-crate",level:3},{value:"Crate settings",id:"crate-settings",level:3},{value:"No standard library",id:"no-standard-library",level:4},{value:"No <code>main</code> function",id:"no-main-function",level:4},{value:"Toolchain setting",id:"toolchain-setting",level:4},{value:"rust-toolchain.toml",id:"rust-toolchaintoml",level:5},{value:"Memory layout",id:"memory-layout",level:4},{value:"<code>memory.x</code>",id:"memoryx",level:5},{value:"<code>build.rs</code>",id:"buildrs",level:5},{value:"Adding the Dependencies",id:"adding-the-dependencies",level:4},{value:"<code>embassy-executor</code>",id:"embassy-executor",level:5},{value:"<code>embassy-time</code>",id:"embassy-time",level:5},{value:"<code>embassy-rp</code>",id:"embassy-rp",level:4},{value:"<code>embassy-usb-logger</code>",id:"embassy-usb-logger",level:4},{value:"<code>probe-panic</code>",id:"probe-panic",level:3},{value:"The code",id:"the-code",level:3},{value:"<code>main.rs</code>",id:"mainrs",level:4}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",img:"img",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"embassy-rs-setup",children:"Embassy-rs Setup"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, we will cover the steps needed in order to be able to compile and flash Rust applications for ",(0,i.jsx)(n.strong,{children:"RP2040"}),", the MCU (Microcontroller Unit) found in our ",(0,i.jsx)(n.strong,{children:"Raspberry Pi Pico W"}),"s."]}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.h3,{id:"rust-toolchain",children:"Rust Toolchain"}),"\n",(0,i.jsx)(n.p,{children:"In order to install the tools needed to compile Rust code, follow the next steps, depending on your operating system."}),"\n",(0,i.jsx)(n.h4,{id:"linux",children:"Linux"}),"\n",(0,i.jsx)(n.p,{children:"Run the this command in terminal:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This downloads and runs ",(0,i.jsx)(n.code,{children:"rustup-init.sh"}),", which in turn downloads and runs the correct version of the ",(0,i.jsx)(n.code,{children:"rustup-init"})," executable for your platform."]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.mdxAdmonitionTitle,{}),(0,i.jsxs)(n.p,{children:["Before installing elf2uf2-rs, you need to install  ",(0,i.jsx)(n.code,{children:"pkg-config"})," and ",(0,i.jsx)(n.code,{children:"libudev"}),". You can get it by running the following in your terminal."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"sudo apt-get install pkg-config libudev-dev\n"})})]}),"\n",(0,i.jsx)(n.h4,{id:"windows",children:"Windows"}),"\n",(0,i.jsx)(n.p,{children:"Download the respective executable:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe",children:"RUSTUP-INIT.exe - 64bit"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://static.rust-lang.org/rustup/dist/i686-pc-windows-msvc/rustup-init.exe",children:"RUSTUP-INIT.exe - 32bit"})}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["You may be prompted to install ",(0,i.jsx)(n.a,{href:"https://visualstudio.microsoft.com/visual-cpp-build-tools/",children:"Visual Studio C++ Build tools"}),". If so, follow the instructions from the previous link."]})}),"\n",(0,i.jsxs)(n.p,{children:["The last step is to run ",(0,i.jsx)(n.code,{children:"rustup --version"})," in terminal. If everything went well, you should see an output similar to this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"rustup 1.26.0 (5af9b9484 2023-04-05)\ninfo: This is the version for the rustup toolchain manager, not the rustc compiler.\ninfo: The currently active `rustc` version is `rustc 1.76.0 (07dca489a 2024-02-04)`\n"})}),"\n",(0,i.jsx)(n.h3,{id:"elf2uf2-rs",children:(0,i.jsx)(n.code,{children:"elf2uf2-rs"})}),"\n",(0,i.jsx)(n.p,{children:"This tool is needed to be able to program the board over USB. In order to install it, run the following in your terminal:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"cargo install elf2uf2-rs\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Then, run ",(0,i.jsx)(n.code,{children:"elf2uf2-rs --help"}),". If it was correctly installed, you should see something similar to this in your terminal:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"Usage: elf2uf2-rs [OPTIONS] <INPUT> [OUTPUT]\n\nArguments:\n  <INPUT>   Input file\n  [OUTPUT]  Output file\n\nOptions:\n  -v, --verbose  Verbose\n  -d, --deploy   Deploy to any connected pico\n  -s, --serial   Connect to serial after deploy\n  -h, --help     Print help\n"})}),"\n",(0,i.jsx)(n.h3,{id:"probe-rs",children:(0,i.jsx)(n.code,{children:"probe-rs"})}),"\n",(0,i.jsx)(n.p,{children:"This tool is an embedded debugging and target interaction toolkit. It enables its user to program and debug microcontrollers via a debug probe."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"cargo install probe-rs --features cli --locked\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you are on ",(0,i.jsx)(n.strong,{children:"Linux"})," you will also need to add this ",(0,i.jsx)(n.a,{href:"https://probe.rs/files/69-probe-rs.rules",children:(0,i.jsx)(n.code,{children:"udev"})})," file in ",(0,i.jsx)(n.code,{children:"/etc/udev/rules.d"}),". Then, run:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"udevadm control --reload # to ensure the new rules are used.\n\nudevadm trigger # to ensure the new rules are applied to already added devices.\n"})}),"\n",(0,i.jsx)(n.h3,{id:"vscode-extension-optional",children:"VSCode Extension (Optional)"}),"\n",(0,i.jsxs)(n.p,{children:["For a better experience, go ahead and install the ",(0,i.jsx)(n.strong,{children:"Debugger for probe-rs"})," extension in the Microsoft Extension Marketplace. This will make debugging the program running on the RP2040 as easy as debugging a Rust program running on your host machine."]}),"\n",(0,i.jsx)(n.h2,{id:"flashing-over-usb",children:"Flashing over USB"}),"\n",(0,i.jsx)(n.h3,{id:"compiling",children:"Compiling"}),"\n",(0,i.jsxs)(n.p,{children:["You will need to compile your executable specifically for the RP2040 chip. This chip is based on the ",(0,i.jsx)(n.strong,{children:"ARM Cortex M0+"})," architecture, so we will need to specify our target when compiling. We can do that in multiple ways:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["using a ",(0,i.jsx)(n.code,{children:".cargo/config.toml"})," file:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'[build]\ntarget = "thumbv6m-none-eabi"\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"passing it as a parameter to Cargo:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"cargo build --release --target thumbv6m-none-eabi\n"})}),"\n",(0,i.jsx)(n.h3,{id:"flashing",children:"Flashing"}),"\n",(0,i.jsxs)(n.p,{children:["To flash a program to the Raspberry Pi Pico via USB, it needs to be in ",(0,i.jsx)(n.em,{children:"USB mass storage device mode"}),". To put it in this mode, you need to ",(0,i.jsxs)(n.strong,{children:["hold the ",(0,i.jsx)(n.code,{children:"BOOTSEL"})," button down"]}),"  while connecting it to your PC. Connecting and disconnecting the USB can lead to the port getting damaged, so we conveniently attached a reset button on the breadboard included on the ",(0,i.jsx)(n.strong,{children:"Pico Explorer Base"}),". Now, to make it reflashable again, just press the two buttons simultaneously."]}),"\n",(0,i.jsxs)(n.p,{children:["After connecting the board to your PC and compiling the program, locate the binary in the ",(0,i.jsx)(n.code,{children:"target/thumbv6m-none-eabi/release/"})," folder then, run:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"elf2uf2-rs -d -s /path/to/your/binary\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-d"})," to automatically deploy to a mounted pico"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"-s"})," to open the pico as a serial device after deploy and print serial output"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["On ",(0,i.jsx)(n.code,{children:"Windows"}),", you may need to run this command in a terminal that has ",(0,i.jsx)(n.strong,{children:"Admin Privileges"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"debugging-using-raspberry-pi-debug-probe",children:"Debugging using Raspberry Pi Debug Probe"}),"\n",(0,i.jsxs)(n.p,{children:["In order to be able to debug the program running on the board, we will need to connect the ",(0,i.jsx)(n.strong,{children:"Raspberry Pi Debug Probe"})," to our ",(0,i.jsx)(n.strong,{children:"Raspberry Pi Pico W"}),". Below, you have a picture of the debug kit provided:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Raspberry Pi Debug probe",src:s(17814).A+"",width:"4579",height:"2612"})}),"\n",(0,i.jsxs)(n.p,{children:["To connect them, we will use the ",(0,i.jsx)(n.strong,{children:"3-pin debug to 0.1-inch header (female)"})," cable. First, carefully insert the ",(0,i.jsx)(n.strong,{children:"3-pin debug"})," head in the ",(0,i.jsx)(n.strong,{children:"right side"})," connector. Then you will also need to connect it to the Raspberry Pi Pico W. You will find attached the pinout, take a closer look at the bottom of the image:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Raspberry Pi Pico W pinout",src:s(26491).A+"",width:"842",height:"595"})}),"\n",(0,i.jsx)(n.p,{children:"The connections must be:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Wire"}),(0,i.jsx)(n.th,{children:"Raspberry Pi Pico W"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"TX (Orange)"}),(0,i.jsx)(n.td,{children:"SWCLK"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"GND (Black)"}),(0,i.jsx)(n.td,{children:"GND"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"RX (Yellow)"}),(0,i.jsx)(n.td,{children:"SWDIO"})]})]})]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"Do not forget to connect both the Debug Probe and Pico to your PC."})}),"\n",(0,i.jsx)(n.p,{children:"Now, you can either debug using the command line by running:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"probe-rs run --chip RP2040 path/to/your/binary\n"})}),"\n",(0,i.jsxs)(n.p,{children:["or you can use ",(0,i.jsx)(n.strong,{children:"Debug and Run"})," view in Visual Studio Code. You will need to modify the ",(0,i.jsx)(n.code,{children:"programBinary"})," path in the ",(0,i.jsx)(n.code,{children:".vscode/launch.json"})," config file to point to your binary file."]}),"\n",(0,i.jsx)(n.h2,{id:"building-your-first-embassy-rs-project",children:"Building your first Embassy-rs project"}),"\n",(0,i.jsxs)(n.p,{children:["In this section, we will briefly go over the steps you need to take in order to get your first project using ",(0,i.jsx)(n.strong,{children:"Rust"})," and ",(0,i.jsx)(n.strong,{children:"Embassy-rs"})," going."]}),"\n",(0,i.jsx)(n.h3,{id:"creating-your-crate",children:"Creating your crate"}),"\n",(0,i.jsx)(n.p,{children:"The first step is to create your cargo package by running the following command in your terminal:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"cargo new --vcs none embassy\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"--vcs none"})," because at the moment we do not want to use any code versioning (they are useful, but this is not the purpose of this tutorial)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"crate-settings",children:"Crate settings"}),"\n",(0,i.jsxs)(n.p,{children:["Because we are running in an embedded environment, our code needs to be ",(0,i.jsx)(n.em,{children:'"tailored"'})," specifically for the microcontroller we intend to use. In our case, it is the ",(0,i.jsx)(n.strong,{children:"RP2040"}),", but these general steps apply for any chip, produced by any manufacturer."]}),"\n",(0,i.jsx)(n.h4,{id:"no-standard-library",children:"No standard library"}),"\n",(0,i.jsxs)(n.p,{children:["Due to the size constraints imposed on us (in our case, ",(0,i.jsx)(n.code,{children:"2MB"})," of flash memory), the standard library has to go. We specify that by adding the ",(0,i.jsx)(n.code,{children:"#![no_std]"})," attribute to the beginning of our ",(0,i.jsx)(n.code,{children:"src/mains.rs"})," file."]}),"\n",(0,i.jsxs)(n.h4,{id:"no-main-function",children:["No ",(0,i.jsx)(n.code,{children:"main"})," function"]}),"\n",(0,i.jsxs)(n.p,{children:["Because we are using the ",(0,i.jsx)(n.strong,{children:"Embassy-rs"})," framework, we want to let it take care of the entry point of our program (because it has to do some complex operations, like allocating the ",(0,i.jsx)(n.code,{children:"task-arena"})," and ",(0,i.jsx)(n.code,{children:"executor"})," structures). For the moment, all we will need to do is add the ",(0,i.jsx)(n.code,{children:"#![no_main]"})," attribute to ",(0,i.jsx)(n.code,{children:"src/main.rs"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"toolchain-setting",children:"Toolchain setting"}),"\n",(0,i.jsxs)(n.p,{children:["Our chip is a ",(0,i.jsx)(n.strong,{children:"Cortex-M0+"})," that uses the ",(0,i.jsx)(n.strong,{children:"ThumbV6-M"})," architecture so we will need to specify the target triple we are compiling for. We will do that using a ",(0,i.jsx)(n.code,{children:"rust-toolchain.toml"})," file, as it allows us to also set the ",(0,i.jsx)(n.strong,{children:"toolchain release channel"})," we will use, and the components we require."]}),"\n",(0,i.jsx)(n.p,{children:"An example of such file is this:"}),"\n",(0,i.jsx)(n.h5,{id:"rust-toolchaintoml",children:"rust-toolchain.toml"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Toml",children:'# This file is used to specify the version of the Rust toolchain that \n# should be used for your project.\n\n[toolchain]\n# The release to be used.\nchannel = "1.75"\n# The targets for compilation that need to be added. This is used for \n# cross-compilation, as the executables we are producing need to be\n# run on our boards.\ntargets = ["thumbv6m-none-eabi"]\n# The additional componets to be installed along the Rust toolchain\ncomponents = ["rust-src", "rustfmt", "llvm-tools", "clippy"]\n'})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsx)(n.p,{children:"Please make sure that you install the Rust ARMv6-M target (thumbv6m-none-eabi)."}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"rustup target add thumbv6m-none-eabi\n"})})]}),"\n",(0,i.jsx)(n.h4,{id:"memory-layout",children:"Memory layout"}),"\n",(0,i.jsxs)(n.p,{children:["We also need to take care of the memory layout of our program when writing code for a microcontroller. These can be found in the datasheet of all the microcontrollers. Bellow, you can find the memory layout for the ",(0,i.jsx)(n.strong,{children:"RP2040"}),":"]}),"\n",(0,i.jsx)(n.h5,{id:"memoryx",children:(0,i.jsx)(n.code,{children:"memory.x"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-linker-script",children:"/* Memory regions for the linker script */\n/* Address map provided by datasheet: https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf */\nMEMORY {\n    /* Define the memory region for the second stage bootloader */\n    BOOT2 : ORIGIN = 0x10000000, LENGTH = 0x100\n\n    /* Define the memory region for the application to be loaded next */\n    FLASH : ORIGIN = 0x10000100, LENGTH = 2048K - 0x100\n\n    /* Define the memory region for SRAM */\n    RAM   : ORIGIN = 0x20000000, LENGTH = 264K\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To use the ",(0,i.jsx)(n.code,{children:"memory.x"})," layout file, we will also need to use a build script. Rust facilitates that through the ",(0,i.jsx)(n.code,{children:"build.rs"})," file. Bellow you will find an explained build script you can use."]}),"\n",(0,i.jsx)(n.h5,{id:"buildrs",children:(0,i.jsx)(n.code,{children:"build.rs"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'//! This build script copies the `memory.x` file from the crate root into\n//! a directory where the linker can always find it at build time.\n//! For many projects this is optional, as the linker always searches the\n//! project root directory -- wherever `Cargo.toml` is. However, if you\n//! are using a workspace or have a more complicated build setup, this\n//! build script becomes required. Additionally, by requesting that\n//! Cargo re-run the build script whenever `memory.x` is changed,\n//! updating `memory.x` ensures a rebuild of the application with the\n//! new memory settings.\n\nuse std::env;\nuse std::fs::File;\nuse std::io::Write;\nuse std::path::PathBuf;\n\nfn main() {\n    // Put `memory.x` in our output directory and ensure it\'s\n    // on the linker search path.\n    let out = &PathBuf::from(env::var_os("OUT_DIR").unwrap());\n    File::create(out.join("memory.x"))\n        .unwrap()\n        .write_all(include_bytes!("./memory.x"))\n        .unwrap();\n    println!("cargo:rustc-link-search={}", out.display());\n    println!("cargo:rerun-if-changed={{layout}}");\n\n    // `--nmagic` is required if memory section addresses are not aligned to 0x10000,\n    // for example the FLASH and RAM sections in your `memory.x`.\n    println!("cargo:rustc-link-arg=--nmagic");\n\n    // The `link.x` linker script provided by `cortex_m_rt` (minimal runtime for\n    // Cortex-M microcontrollers used by embassy) will include our `memory.x` memory layout.\n    println!("cargo:rustc-link-arg=-Tlink.x");\n\n    // The `link-rp.x` linker script provided by `embassy_rp` that defines the\n    // BOOT2 section.\n    println!("cargo:rustc-link-arg-bins=-Tlink-rp.x");\n\n    // The `defmt.x` linker script provided by `defmt`.\n    println!("cargo:rustc-link-arg-bins=-Tdefmt.x");\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"adding-the-dependencies",children:"Adding the Dependencies"}),"\n",(0,i.jsxs)(n.p,{children:["At this step, we must add the dependencies we will use for our project. Bellow you will find the basics you will need for a minimal application, including an ",(0,i.jsx)(n.code,{children:"usb_logger"})," to ",(0,i.jsx)(n.em,{children:'"enable"'})," debugging over serial."]}),"\n",(0,i.jsx)(n.h5,{id:"embassy-executor",children:(0,i.jsx)(n.code,{children:"embassy-executor"})}),"\n",(0,i.jsxs)(n.p,{children:["This is an ",(0,i.jsx)(n.code,{children:"async/await"})," executor designed for embedded. To add it as a dependency to your project, run:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"cargo add embassy-executor --features arch-cortex-m,executor-thread,executor-interrupt,integrated-timers,task-arena-size-32768\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"arch-cortex-m"})," - feature to specify we are running on the cortex M architecture"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"executor-thread"})," - enable the thread-mode executor (using WFE/SEV in Cortex-M, WFI in other embedded archs)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"executor-interrupt"})," - enable the interrupt-mode executor (available in Cortex-M only)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"integrated-timers"})," - use the executor-integrated embassy-time timer queue."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"task-arena-size-X"})," - sets the task arena size"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["We will also need to add the ",(0,i.jsx)(n.code,{children:"cortex-m"})," and ",(0,i.jsx)(n.code,{children:"cortex-m-rt"})," crates as dependencies, as the ",(0,i.jsx)(n.code,{children:"#[executor::main]"})," attribute depends on the minimal startup code for the Cortex M microcontrollers found in this crates. To do that, run:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"cargo add cortex-m\ncargo add cortex-m-rt\n"})}),"\n",(0,i.jsx)(n.h5,{id:"embassy-time",children:(0,i.jsx)(n.code,{children:"embassy-time"})}),"\n",(0,i.jsx)(n.p,{children:"This crate enables timekeeping, timeouts and delays. Add it by running:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"cargo add embassy-time\n"})}),"\n",(0,i.jsx)(n.h4,{id:"embassy-rp",children:(0,i.jsx)(n.code,{children:"embassy-rp"})}),"\n",(0,i.jsxs)(n.p,{children:["This crate is a ",(0,i.jsx)(n.strong,{children:"Hardware Abstraction Layer"})," for the ",(0,i.jsx)(n.strong,{children:"RP2040"}),". You can add it to your project like so:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"cargo add embassy-rp --features time-driver,critical-section-impl\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"time-driver"})," - enable the timer for use with ",(0,i.jsx)(n.code,{children:"embassy-time"})," with a ",(0,i.jsx)(n.code,{children:"1MHz"})," tick rate."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"critical-section-impl"})," - configure the critical section crate to use an implementation that is safe for multicore use on RP2040"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"embassy-usb-logger",children:(0,i.jsx)(n.code,{children:"embassy-usb-logger"})}),"\n",(0,i.jsxs)(n.p,{children:["USB implementation of the ",(0,i.jsx)(n.code,{children:"log"})," crate. It allows the usage of ",(0,i.jsx)(n.code,{children:"info!"})," macro and some more. To add it, run the following command:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"cargo add log\ncargo add embassy-usb-logger\n"})}),"\n",(0,i.jsx)(n.h3,{id:"probe-panic",children:(0,i.jsx)(n.code,{children:"probe-panic"})}),"\n",(0,i.jsxs)(n.p,{children:["This crate adds a panic handler for the microchip that prints panic messages over ",(0,i.jsx)(n.strong,{children:"JTAG"}),", and in order to add it, run:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"cargo add panic-probe\n"})}),"\n",(0,i.jsx)(n.h3,{id:"the-code",children:"The code"}),"\n",(0,i.jsxs)(n.p,{children:["Here you can find a minimally explained code that prints ",(0,i.jsx)(n.code,{children:'"Hello World!"'})," over the serial interface:"]}),"\n",(0,i.jsx)(n.h4,{id:"mainrs",children:(0,i.jsx)(n.code,{children:"main.rs"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#![no_std]\n#![no_main]\n\nuse embassy_executor::Spawner;\nuse embassy_rp::bind_interrupts;\nuse embassy_rp::peripherals::USB;\nuse embassy_rp::usb::{Driver, InterruptHandler as UsbInterruptHandler};\nuse embassy_time::Timer;\nuse log::info;\nuse panic_probe as _;\n\n// Bind interrupts to their handlers.\nbind_interrupts!(struct Irqs {\n    USBCTRL_IRQ => UsbInterruptHandler<USB>;\n});\n\n// Async task for USB logging.\n#[embassy_executor::task]\nasync fn logger_task(driver: Driver<\'static, USB>) {\n    embassy_usb_logger::run!(1024, log::LevelFilter::Info, driver);\n}\n\n#[embassy_executor::main]\nasync fn main(spawner: Spawner) {\n    // Initialize peripherals and USB driver.\n    let rp_peripherals = embassy_rp::init(Default::default());\n    let usb_driver = Driver::new(rp_peripherals.USB, Irqs);\n\n    // Spawn the logger task\n    spawner.spawn(logger_task(usb_driver)).unwrap();\n    \n    Timer::after_millis(1000).await;\n    info!("Hello, world!");\n\n    loop {\n        Timer::after_millis(10).await;\n    }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},26491:(e,n,s)=>{s.d(n,{A:()=>r});const r=s.p+"assets/images/picow-pinout-53d738f9b62492655771d028c1a11829.svg"},17814:(e,n,s)=>{s.d(n,{A:()=>r});const r=s.p+"assets/images/the-probe-f15ab4734e339bf07b3daafcf3005f0d.png"},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var r=s(96540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);